Below is a **surgical repair plan** that closes the last gap between your **data pipeline (100 % OK)** and the **presentation layer (currently broken)**.
Follow the steps in order; everything else in the chain you listed is already working exactly as intended.

---

## 1 Root‑cause analysis

| Symptom                                                               | File(s)                                                               | Explanation                                                                                                                                       |
| --------------------------------------------------------------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<LabeledText>` renders plain text, no effects                        | **`VirtualRow.tsx`** passes props `{text, labelData, activeLabels…}`  | but **`LabeledText.tsx`** expects `{text, mask, segmentKey}` . Nothing inside the component ever reads `labelData`, so no bitmap, no CSS classes. |
| State updates *do* reach the table (logs show `activeLabels` changes) | **`VirtualBibleTable.tsx`** logs confirm the store fires              | React re‑renders, but the final leaf component throws away the info.                                                                              |
| Worker & cache are fine                                               | `labels.worker.ts`, `labelsCache.ts`, hooks all run                   | They populate `getVerseLabels()` correctly; the data simply never reaches the DOM.                                                                |

**Therefore:** only the renderer (steps 9–11 of your chain) is missing.

---

## 2 Files to add / replace

| Path                                          | Action                                                                                                                                 |
| --------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `client/src/lib/labelRenderer.ts`             | **NEW** – maps bitmask ➜ CSS class list (10 lines).                                                                                    |
| `client/src/hooks/useLabeledText.ts`          | **NEW** – turns `(text, labelData, activeLabels)` into an array of `{start,end,mask}` segments, using the 10‑bit sweep‑line algorithm. |
| `client/src/components/bible/LabeledText.tsx` | **REPLACE** with a version that calls the hook above and renders `<span className={classes}>…</span>` fragments.                       |

*No other file needs to change.*
VirtualRow, VirtualBibleTable, the Worker and the Zustand store will “just work” once these three pieces are in place.

---

### 2.1 `labelRenderer.ts`

```ts
import { LabelBits, LabelMask } from '@/lib/labelBits';

export function classesForMask(mask: LabelMask): string {
  if (!mask) return '';
  const cls: string[] = [];
  if (mask & LabelBits.who)        cls.push('fx-hand');
  if (mask & LabelBits.what)       cls.push('fx-shadow');
  if (mask & LabelBits.when)       cls.push('fx-under');
  if (mask & LabelBits.where)      cls.push('fx-bracket');
  if (mask & LabelBits.command)    cls.push('fx-bold');
  if (mask & LabelBits.action)     cls.push('fx-ital');
  if (mask & LabelBits.why)        cls.push('fx-outline');
  if (mask & LabelBits.seed)       cls.push('sup-seed');
  if (mask & LabelBits.harvest)    cls.push('sup-harvest');
  if (mask & LabelBits.prediction) cls.push('sup-predict');
  return cls.join(' ');
}
```

---

### 2.2 `useLabeledText.ts`

```ts
import { useMemo } from 'react';
import { LabelBits } from '@/lib/labelBits';

export interface Segment { start: number; end: number; mask: number; }

export function useLabeledText(
  text: string,
  labelData: Record<string, string[]>,
  activeLabels: (keyof typeof LabelBits)[]
): Segment[] {

  return useMemo(() => {
    if (!text || activeLabels.length === 0) {
      return [{ start: 0, end: text.length, mask: 0 }];
    }

    type Ev = { pos: number; bit: number; add: boolean };
    const events: Ev[] = [];

    activeLabels.forEach(lbl => {
      const bit = LabelBits[lbl];
      const phrases = labelData?.[lbl] || [];
      phrases.forEach(ph => {
        if (!ph) return;
        const re = new RegExp(
          ph.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\W+'),
          'gi'
        );
        let m: RegExpExecArray | null;
        while ((m = re.exec(text))) {
          events.push({ pos: m.index, add: true,  bit });
          events.push({ pos: m.index + m[0].length, add: false, bit });
        }
      });
    });

    if (!events.length) return [{ start: 0, end: text.length, mask: 0 }];

    events.sort((a, b) => a.pos - b.pos || (a.add ? -1 : 1));

    const segs: Segment[] = [];
    let mask = 0, last = 0;

    for (const { pos, bit, add } of events) {
      if (pos > last) segs.push({ start: last, end: pos, mask });
      mask = add ? (mask | bit) : (mask & ~bit);
      last = pos;
    }
    if (last < text.length) segs.push({ start: last, end: text.length, mask });
    return segs;
  }, [text, JSON.stringify(labelData), activeLabels.join()]);
}
```

---

### 2.3 `LabeledText.tsx`

```tsx
import React from 'react';
import { useLabeledText } from '@/hooks/useLabeledText';
import { classesForMask } from '@/lib/labelRenderer';

interface LabeledTextProps {
  text: string;
  labelData: Record<string, string[]>;
  activeLabels: string[];
  verseKey: string;
  translationCode: string;
}

export function LabeledText({
  text,
  labelData,
  activeLabels,
  verseKey,
}: LabeledTextProps) {
  const segs = useLabeledText(text, labelData, activeLabels as any);

  return (
    <>
      {segs.map((s) => {
        const cls = classesForMask(s.mask);
        const key = `${verseKey}-${s.start}-${s.mask}`;
        return cls ? (
          <span key={key} className={cls}>
            {text.slice(s.start, s.end)}
          </span>
        ) : (
          text.slice(s.start, s.end)
        );
      })}
    </>
  );
}
```

*`VirtualRow.tsx` already imports and uses `<LabeledText>` with the correct props* , so once this replacement compiles the UI will light up.

---

## 3 Why this is still fast

* **File fetched once:** `labels.worker.ts` downloads `ALL.json` a single time, then serves filtered slices from in‑worker cache.
* **Bitmap layers:** Each highlight combination is a **bit in a `uint16`**, merged into one `<span>`; no nested DOM, no GC churn.
* **Viewport only:** `useViewportLabels` still ensures that only verses in view call the hook; others stay dormant.
* **Co‑existence with other features:** All other data (cross refs, prophecy, dates …) live in separate Zustand slices (see **`App.tsx`** store)  and don’t share code paths or memory with the label renderer.

---

## 4 Quick validation checklist

1. **Toggle two labels** → Network panel shows **0 B** after the first fetch; spans gain multiple classes like `fx-hand fx-shadow`.
2. **Scroll a chapter** → Chrome Performance flame‑graph shows < 2 ms scripting per frame.
3. **Memory snapshot after 1 000 verses scrolled** → Heap plateau ≤ 5 MB.

If any of these fail, the culprit is almost always a missing CSS rule or a stray per‑character loop that sneaked back in.

---

### Hand this block to your agent

> **Implement steps 2.1, 2.2, 2.3 above**.
> Do **not** touch worker, cache, or store code.
> After build, verify that toggling labels adds CSS classes and keeps FPS at 60.

Once those three small files are in your repo, the label overlay system will finally render—and it will remain buttery smooth alongside every other feature on the site.
