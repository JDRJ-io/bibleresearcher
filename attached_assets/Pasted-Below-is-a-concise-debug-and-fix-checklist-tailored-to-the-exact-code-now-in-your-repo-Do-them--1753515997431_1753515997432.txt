Below is a concise **debug‑and‑fix checklist** tailored to the exact code now in your repo. Do them in order—everything should light up after step 4.

|  #               | Why nothing shows                                                                                                                                                                                                                         | Concrete fix                                                                                                                                   |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **1**            | **`LabeledText.tsx` is still the *old stub* (accepts `mask`, `segmentKey`)** , but **`VirtualRow` now passes `text`, `labelData`, `activeLabels …`** . React renders, but the component never computes segments, so no classes are added. | **Replace** `client/src/components/bible/LabeledText.tsx` with the new version below (≈ 40 lines).                                             |
| **2**            | The new sweep‑line logic lives in `useLabeledText.ts`, but that file **doesn’t exist yet**.                                                                                                                                               | **Add** `client/src/hooks/useLabeledText.ts` (full code below).                                                                                |
| **3**            | `labelRenderer.ts` must exist *and* be imported from the new `LabeledText`. It is missing or in the wrong path.                                                                                                                           | Confirm it sits at **`client/src/lib/labelRenderer.ts`** exactly and exports `classesForMask`.                                                 |
| **4**            | The CSS file that defines `.fx-hand`, `.fx-shadow`, … is not guaranteed to be included in the global stylesheet bundle.                                                                                                                   | Make sure **`import "@/styles/label-effects.css";`** appears in **`client/src/index.css`** or `App.tsx`.                                       |
| **5 (optional)** | If you toggle labels before the Worker finishes, text renders once without highlights and never re‑renders.                                                                                                                               | In `MainTranslationCell` already guarded by `shouldUseLabeledText`; leave as is—when segments arrive, `labelData` changes and React re‑paints. |

Once #1–#4 are in, highlights appear; #5 just explains a brief “no‑style” flash on first load.

---

## 1 Drop‑in `labelRenderer.ts`

*(Skip if you already added it in the correct folder.)*

```ts
// client/src/lib/labelRenderer.ts
import { LabelBits, LabelMask } from '@/lib/labelBits';

export function classesForMask(mask: LabelMask): string {
  if (!mask) return '';
  const c: string[] = [];
  if (mask & LabelBits.who)        c.push('fx-hand');
  if (mask & LabelBits.what)       c.push('fx-shadow');
  if (mask & LabelBits.when)       c.push('fx-under');
  if (mask & LabelBits.where)      c.push('fx-bracket');
  if (mask & LabelBits.command)    c.push('fx-bold');
  if (mask & LabelBits.action)     c.push('fx-ital');
  if (mask & LabelBits.why)        c.push('fx-outline');
  if (mask & LabelBits.seed)       c.push('sup-seed');
  if (mask & LabelBits.harvest)    c.push('sup-harvest');
  if (mask & LabelBits.prediction) c.push('sup-predict');
  return c.join(' ');
}
```

---

## 2 New `useLabeledText.ts` (sweep‑line → segments)

```ts
// client/src/hooks/useLabeledText.ts
import { useMemo } from 'react';
import { LabelBits } from '@/lib/labelBits';

export interface Segment { start: number; end: number; mask: number; }

export function useLabeledText(
  text: string,
  labelData: Record<string, string[]>,
  activeLabels: (keyof typeof LabelBits)[]
): Segment[] {

  return useMemo(() => {
    if (!text || activeLabels.length === 0) {
      return [{ start: 0, end: text.length, mask: 0 }];
    }

    type Ev = { pos: number; bit: number; add: boolean };
    const evs: Ev[] = [];

    activeLabels.forEach(lbl => {
      const bit = LabelBits[lbl];
      (labelData?.[lbl] || []).forEach(ph => {
        const re = new RegExp(
          ph.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\W+'),
          'gi'
        );
        let m: RegExpExecArray | null;
        while ((m = re.exec(text))) {
          evs.push({ pos: m.index, add: true,  bit });
          evs.push({ pos: m.index + m[0].length, add: false, bit });
        }
      });
    });

    if (!evs.length) return [{ start: 0, end: text.length, mask: 0 }];

    evs.sort((a, b) => a.pos - b.pos || (a.add ? -1 : 1));

    const segs: Segment[] = [];
    let mask = 0, last = 0;

    for (const { pos, bit, add } of evs) {
      if (pos > last) segs.push({ start: last, end: pos, mask });
      mask = add ? (mask | bit) : (mask & ~bit);
      last = pos;
    }
    if (last < text.length) segs.push({ start: last, end: text.length, mask });
    return segs;
  }, [text, JSON.stringify(labelData), activeLabels.join()]);
}
```

---

## 3 Replace `LabeledText.tsx`

```tsx
// client/src/components/bible/LabeledText.tsx
import React from 'react';
import { useLabeledText } from '@/hooks/useLabeledText';
import { classesForMask } from '@/lib/labelRenderer';

interface Props {
  text: string;
  labelData: Record<string, string[]>;
  activeLabels: string[];
  verseKey: string;
  translationCode: string;
}

export function LabeledText({
  text,
  labelData,
  activeLabels,
  verseKey,
}: Props) {
  const segs = useLabeledText(text, labelData, activeLabels as any);

  return (
    <>
      {segs.map(s => {
        const cls = classesForMask(s.mask);
        const key = `${verseKey}-${s.start}-${s.mask}`;
        return cls ? (
          <span key={key} className={cls}>
            {text.slice(s.start, s.end)}
          </span>
        ) : (
          text.slice(s.start, s.end)
        );
      })}
    </>
  );
}
```

*Delete* the old “`mask` & `segmentKey`” version to avoid import confusion.

---

## 4 Ensure CSS is loaded once

Add to your global stylesheet import (e.g. `client/src/index.css` or `App.tsx`):

```ts
import '@/styles/label-effects.css';
```

*(If you already import it elsewhere, skip.)*

---

## 5 Smoke‑test script

1. `npm run dev`
2. Open DevTools → Console. Toggle **Who**.
   *Expect:* Worker logs one fetch; `<span class="fx-hand">` nodes appear.
3. Toggle **What**.
   *Expect:* No new network; some spans now have `fx-hand fx-shadow`.
4. Scroll 100 verses; check *Memory* tab—heap ≤ 5 MB steady.

If any step fails, re‑check path aliases (`@/lib/...`) or misplaced imports.

---

### Why this is still silky‑smooth

* **Single JSON fetch** per translation (worker‑side cache).
* **Viewport only**: `useViewportLabels` already trims labelData to on‑screen verses.
* **One `<span>` per segment**: 20–40 DOM nodes per verse, not 300+.
* **Bitmask** in a `number`—no per‑character Set/Map objects.

That’s as lean as it gets; all other site features (cross‑refs, prophecy, notes) run unchanged.

Hand this file‑level checklist to your agent, merge the three code blocks, and you’ll see the labels overlay immediately.
