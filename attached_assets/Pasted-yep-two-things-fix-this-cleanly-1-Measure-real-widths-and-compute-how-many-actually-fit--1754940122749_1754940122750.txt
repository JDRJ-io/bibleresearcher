yep — two things fix this cleanly:

1. **Measure real widths** and compute how many actually fit (so a 200% column yields 1-of-N).
2. **Allow a trailing “ghost slot”** so you can always land on the very last column even if only one fits there (no fake numbering, just removes the “needs 3 to move” wall).

Here’s a drop-in update to the function I gave you. It adds a `ghostSlots` option (defaults to `1`) and keeps everything else dynamic by pixel width.

```ts
type ColumnId = 'KJV' | 'CrossRefs' | 'Prediction' | 'Fulfillment' | 'Verification';

type LayoutParams = {
  containerWidthPx: number;        // total width (incl. pillar)
  pillarWidthPx: number;           // sticky Ref/# width
  gapPx: number;                   // px gap between columns
  activeColumns: ColumnId[];       // excludes pillar

  // Prefer measured widths; else base*zoom
  widthsPx?: number[];             
  baseWidths?: Record<ColumnId, number>;
  zoom?: number;

  offset: number;                  // 0-based, excludes pillar
  ghostSlots?: number;             // << NEW: trailing ghost to allow final single-column page (default 1)
};

type LayoutResult = {
  contentViewportPx: number;
  startIndex: number;              // 0-based
  endIndex: number;                // inclusive
  visibleCount: number;            // how many actually fit
  labelStart: number;              // 1-based
  labelEnd: number;                // 1-based
  totalNavigableColumns: number;
  canGoLeft: boolean;
  canGoRight: boolean;
};

export function computeVisibleRangeDynamic(p: LayoutParams): LayoutResult {
  const contentViewportPx = Math.max(0, p.containerWidthPx - p.pillarWidthPx);
  const total = p.activeColumns.length;
  const ghostSlots = Math.max(0, p.ghostSlots ?? 1);

  // Build widths
  let widths: number[];
  if (p.widthsPx && p.widthsPx.length === total) {
    widths = p.widthsPx.map(w => Math.max(1, Math.round(w)));
  } else {
    const zoom = p.zoom ?? 1;
    const base = p.baseWidths ?? {} as Record<ColumnId, number>;
    widths = p.activeColumns.map(id => Math.max(1, Math.round((base[id] ?? 320) * zoom)));
  }

  if (total === 0) {
    return {
      contentViewportPx,
      startIndex: 0, endIndex: -1, visibleCount: 0,
      labelStart: 0, labelEnd: 0, totalNavigableColumns: 0,
      canGoLeft: false, canGoRight: false
    };
  }

  // Clamp starting index first
  let start = Math.max(0, Math.min(p.offset, total - 1));

  // How many fit from 'start' by pixels
  const fitFrom = (s: number) => {
    let used = 0, count = 0;
    for (let i = s; i < total; i++) {
      const next = count === 0 ? widths[i] : used + p.gapPx + widths[i];
      if (next > contentViewportPx) break;
      used = next; count++;
    }
    return Math.max(1, count); // show at least one even if too wide
  };

  // Compute visible at current start
  let visible = fitFrom(start);

  // Trailing-ghost clamp: allow start to go as far as total - visible + ghostSlots
  const maxStart = Math.max(0, total - Math.max(1, visible) + ghostSlots);
  if (start > maxStart) {
    start = maxStart;
    visible = fitFrom(start); // recompute for new start (may drop to 1 at the end)
  }

  const end = Math.min(start + visible - 1, total - 1);

  return {
    contentViewportPx,
    startIndex: start,
    endIndex: end,
    visibleCount: visible,
    labelStart: start + 1,
    labelEnd: end + 1,
    totalNavigableColumns: total,
    canGoLeft: start > 0,
    canGoRight: end < total - 1, // still true until we’re really at the last column
  };
}
```

### Wire-up (key bits)

* **Measure real widths** of each visible column wrapper (not cells) with a `ResizeObserver` and pass them as `widthsPx`. This guarantees 200% columns collapse the page to `1–1/N`.

```ts
// example measuring
const ro = new ResizeObserver(entries => {
  const map: number[] = [];
  activeColumns.forEach((id, i) => {
    const el = document.querySelector(`[data-col="${id}"]`) as HTMLElement | null;
    map[i] = el ? Math.round(el.getBoundingClientRect().width) : 0;
  });
  setWidthsPx(map);
});
ro.observe(contentRef.current!); // and/or observe each column wrapper
```

* **Compute** with ghost slot so the last column is always reachable:

```ts
const res = computeVisibleRangeDynamic({
  containerWidthPx: Math.round(wrapperRef.current!.getBoundingClientRect().width),
  pillarWidthPx:    Math.round(pillarRef.current!.getBoundingClientRect().width),
  gapPx: 12,
  activeColumns, widthsPx, // prefer measured
  // baseWidths, zoom,      // fallback if you skip measuring
  offset,
  ghostSlots: 1,            // <-- important
});

// arrows: always move one column
function goRight(){ if (res.canGoRight) setOffset(res.startIndex + 1); }
function goLeft(){  if (res.canGoLeft)  setOffset(res.startIndex - 1); }
```

### What you’ll see

* Normal sizes → **page 1 label** will be `1–2/5` (because two fit).
* If you crank a column to **200%** width → label becomes `1–1/5` (only one fits).
* You can keep clicking → to reach the **very last** column even if it only shows by itself (no “needs 3 columns to move” issue).
* No need to fake a hidden numbered column; the **ghost slot** only affects the clamp so navigation can land on the last item.

If your label still shows `1–1/5` while two are visibly on screen, that’s a measuring issue—point the `ResizeObserver` at the **column wrappers you page by** and feed those widths in; don’t rely on base sizes when zoom/scale is active.
