Absolutely. Here’s an end-to-end, drop-in fix that makes navigation, headers, and column widths share one dynamic source of truth. It replaces the static maxVisibleColumns with a measured visibleCount, updates on resize/drag, and keeps sticky headers perfectly in sync.

I’ll show this as small, focused patches so you can paste them in.

⸻

1) Store: add visibleCount + helpers

Assuming Zustand:

// store/layoutStore.ts
import create from 'zustand';

type LayoutState = {
  // existing:
  columnOffset: number;
  fixedColumns: string[];            // ids of sticky/fixed columns (e.g., Index, Main)
  navigableColumns: string[];        // ids for scrollable columns in order
  columnWidthsPx: Record<string, number>; // resolved px widths per column id
  containerWidthPx: number;

  // NEW:
  visibleCount: number;              // dynamically computed how many navigable columns fit
  overscanColumns: number;           // optional +1 column for smoother nav

  // actions
  setVisibleCount: (n: number) => void;
  setContainerWidthPx: (w: number) => void;
  setColumnWidthPx: (id: string, w: number) => void;

  // derived helpers
  getVisibleSlice: () => { start: number; end: number };
};

export const useLayoutStore = create<LayoutState>((set, get) => ({
  // existing defaults ...
  columnOffset: 0,
  fixedColumns: [],
  navigableColumns: [],
  columnWidthsPx: {},
  containerWidthPx: 0,

  // NEW defaults
  visibleCount: 1,
  overscanColumns: 0, // set to 1 if you want the hidden “+1 column” behavior

  setVisibleCount: (n) => set({ visibleCount: Math.max(1, n) }),
  setContainerWidthPx: (w) => set({ containerWidthPx: Math.max(0, w) }),
  setColumnWidthPx: (id, w) =>
    set((s) => ({ columnWidthsPx: { ...s.columnWidthsPx, [id]: w } })),

  getVisibleSlice: () => {
    const { columnOffset, fixedColumns, visibleCount, overscanColumns, navigableColumns } = get();
    const take = Math.max(0, visibleCount - fixedColumns.length) + overscanColumns;
    const start = columnOffset;
    const end = Math.min(navigableColumns.length, start + take);
    return { start, end };
  }
}));


⸻

2) Hook: measure how many columns actually fit

This hook computes visibleCount from real DOM widths. Use it once in your column area (the same place you were doing nav math). It re-computes on resize and when any column width changes.

// hooks/useMeasureVisibleColumns.ts
import { useEffect } from 'react';
import { useLayoutStore } from '@/store/layoutStore';

export function useMeasureVisibleColumns(containerEl: HTMLElement | null) {
  const {
    fixedColumns,
    navigableColumns,
    columnWidthsPx,
    setVisibleCount,
    setContainerWidthPx
  } = useLayoutStore();

  useEffect(() => {
    if (!containerEl) return;

    const ro = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const width = Math.round(entry.contentRect.width);
        setContainerWidthPx(width);

        // How many total columns (fixed + as many navigable as fit) can we show?
        // We count fixed first, then add navigable until we run out of room.
        let used = 0;
        let count = 0;

        // include fixed
        for (const id of fixedColumns) {
          const w = Math.max(1, columnWidthsPx[id] ?? 0);
          used += w;
          count += 1;
        }

        // then navigable
        for (const id of navigableColumns) {
          const w = Math.max(1, columnWidthsPx[id] ?? 0);
          if (used + w <= width || count === 0) {
            // allow at least one column even if > width (e.g., 200% zoom case)
            used += w;
            count += 1;
          } else {
            break;
          }
        }

        setVisibleCount(count);
      }
    });

    ro.observe(containerEl);
    return () => ro.disconnect();
  }, [containerEl, fixedColumns, navigableColumns, columnWidthsPx, setVisibleCount, setContainerWidthPx]);
}

Notes
	•	This uses actual px widths (from your column resizer or computed style) so 200% cases correctly collapse to 1 visible column.
	•	It updates visibleCount in the store — the single source of truth everyone will read.

⸻

3) Publish widths when columns resize

Wherever you resize columns (drag handles or CSS-to-px resolution), call setColumnWidthPx(id, px) so the hook above can do correct math.

// somewhere in your column component when width changes
import { useLayoutStore } from '@/store/layoutStore';

// on width change:
const setColumnWidthPx = useLayoutStore(s => s.setColumnWidthPx);
setColumnWidthPx(columnId, measuredPx);

If today you store widths as CSS percentages/vars, resolve to px (via getBoundingClientRect().width) once per change and feed px to the store.

⸻

4) Navigation arrows: stop owning the count; subscribe to it

Make the arrows read visibleCount from the store and never compute their own divergent count.

// components/ColumnNavigationArrows.tsx
import { useLayoutStore } from '@/store/layoutStore';

export function ColumnNavigationArrows() {
  const {
    columnOffset,
    setVisibleCount,            // if you were setting before, you can now delete your local math
    visibleCount,
    navigableColumns,
    getVisibleSlice
  } = useLayoutStore();

  const { start, end } = getVisibleSlice();
  const totalNavigable = navigableColumns.length;

  const canLeft = start > 0;
  const canRight = end < totalNavigable;

  const left = () => {
    // adjust columnOffset in your existing store action
    // e.g., setColumnOffset(Math.max(0, columnOffset - 1));
  };

  const right = () => {
    // e.g., setColumnOffset(Math.min(totalNavigable - 1, columnOffset + 1));
  };

  return (
    <div className="col-nav">
      <button disabled={!canLeft} onClick={left}>◀</button>
      <span>
        {/* Example: show "1-1/5" based on store-derived slice */}
        {`${start + 1}-${Math.max(start + 1, end)}/${totalNavigable}`}
      </span>
      <button disabled={!canRight} onClick={right}>▶</button>
      <small style={{ opacity: 0.7 }}>
        {/* Debug aid */}
        fit={visibleCount} range={start + 1}-{end}
      </small>
    </div>
  );
}


⸻

5) Headers: replace maxVisibleColumns with dynamic slice

This is the exact bug you flagged. Swap the slice to the derived range.

// components/NewColumnHeaders.tsx
- const offsetNavigableColumns = navigableColumns.slice(
-   columnOffset,
-   columnOffset + maxVisibleColumns - fixedColumns.length
- );

+ import { useLayoutStore } from '@/store/layoutStore';
+ const { getVisibleSlice } = useLayoutStore();
+ const { start, end } = getVisibleSlice();
+ const offsetNavigableColumns = navigableColumns.slice(start, end);

Now headers and body read the same visible window.

If you need the full column list to render (fixed + visible navigable):

const headerColumns = [...fixedColumns, ...offsetNavigableColumns];

…and render sticky styles for the fixed ones as you already do.

⸻

6) Mount the measuring hook once

Attach the measuring hook to the scrollable column container element so it always tracks real estate changes (window resize, panel open/close, user drag).

// components/ColumnContainer.tsx
import { useRef, useEffect } from 'react';
import { useMeasureVisibleColumns } from '@/hooks/useMeasureVisibleColumns';

export function ColumnContainer({ children }) {
  const ref = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    // if you also use an inner scroller, pass that instead
  }, []);

  useMeasureVisibleColumns(ref.current);

  return (
    <div ref={ref} className="columns-scroller">
      {children}
    </div>
  );
}


⸻

7) Optional: enable the “hidden +1” navigation feel

If you want that extra wiggle room you mentioned, just set:

// at app init or feature flag
useLayoutStore.setState({ overscanColumns: 1 });

This keeps headers/content in sync while letting the arrows step to one more column than strictly visible, which resolves the “can’t reach last column” feeling without lying to the UI.

⸻

8) Kill the interval poller (perf)

Anywhere you had setInterval(getComputedStyle, 250), replace with ResizeObserver and direct store updates (as above). That removes the silent CPU tax and guarantees instant header/body sync.

⸻

What this fixes (quick checklist)
	•	✅ Single dynamic visibleCount for both navigation & headers
	•	✅ Correct behavior at extreme zoom/200% width (1 column fits → headers show 1)
	•	✅ Sticky fixed columns preserved (they’re counted first)
	•	✅ Optional “hidden +1” overscan without desync
	•	✅ No more polling; instant updates on resize/drag

If you want, paste me the current NewColumnHeaders.tsx and ColumnNavigationArrows.tsx around the relevant lines and I’ll splice these patches into your exact code so it’s copy-ready.