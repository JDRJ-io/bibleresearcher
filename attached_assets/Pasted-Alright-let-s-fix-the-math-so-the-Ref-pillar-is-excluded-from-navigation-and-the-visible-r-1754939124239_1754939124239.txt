Alright, let’s fix the math so the **Ref/# pillar is excluded** from navigation, and the **visible range** adapts when columns get bigger.

Below is a drop-in layout core you can use anywhere (VirtualBibleTable, NewColumnHeaders, etc.). It:

* treats `ref/#` as a fixed **pillar** (never counted in pages),
* computes the **content viewport width** = container − pillar,
* supports **variable column widths** and a **zoom/size factor**,
* returns the correct **visible range** (start–end), **canGoLeft/Right**, and clamps offsets.

---

### 1) Core math (TypeScript)

```ts
type ColumnId = 'KJV' | 'CrossRefs' | 'Prediction' | 'Fulfillment' | 'Verification';

type LayoutParams = {
  // Pixels
  containerWidthPx: number;    // the total width of the scrolling area INCLUDING the pillar
  pillarWidthPx: number;       // measured width of the sticky Ref/# pillar
  gapPx: number;               // horizontal gap between columns (if any)

  // Which columns are currently toggled on (excluding pillar)
  activeColumns: ColumnId[];

  // Widths per column type at zoom=1 (in px). Adjust these to your design.
  baseWidths: Record<ColumnId, number>;

  // Current UI zoom / size factor for columns (1.0 = base, 1.2 = 20% wider, etc.)
  zoom: number;

  // Target number of content columns to show per “page”
  // e.g., portrait = 2, landscape = 3 (not counting the pillar)
  targetSlots: number;

  // Current left-offset index in the activeColumns array (0-based)
  offset: number;
};

type LayoutResult = {
  contentViewportPx: number;     // containerWidthPx - pillarWidthPx
  totalNavigableColumns: number; // activeColumns.length
  visibleCount: number;          // how many content columns we’ll show this page
  startIndex: number;            // 0-based index into activeColumns
  endIndex: number;              // inclusive 0-based index
  labelStart: number;            // 1-based for display
  labelEnd: number;              // 1-based for display
  canGoLeft: boolean;
  canGoRight: boolean;
};

export function computeVisibleRange(p: LayoutParams): LayoutResult {
  const contentViewportPx = Math.max(0, p.containerWidthPx - p.pillarWidthPx);
  const totalNavigableColumns = p.activeColumns.length;
  const widths = p.activeColumns.map(id => Math.max(1, Math.round(p.baseWidths[id] * p.zoom)));

  // If nothing to show, return a neutral result
  if (totalNavigableColumns === 0) {
    return {
      contentViewportPx,
      totalNavigableColumns,
      visibleCount: 0,
      startIndex: 0,
      endIndex: -1,
      labelStart: 0,
      labelEnd: 0,
      canGoLeft: false,
      canGoRight: false
    };
  }

  // Clamp offset to valid range; we’ll refine after we know visibleCount
  let offset = Math.max(0, Math.min(p.offset, totalNavigableColumns - 1));

  // Compute how many columns fit starting at `offset`, but
  // NEVER exceed targetSlots; ALWAYS show at least 1.
  const fitCount = (start: number): number => {
    let count = 0;
    let used = 0;
    for (let i = start; i < totalNavigableColumns; i++) {
      const w = widths[i];
      const next = (count === 0 ? w : used + p.gapPx + w);
      if (next > contentViewportPx) break;
      used = next;
      count++;
      if (count >= p.targetSlots) break; // hard cap
    }
    return Math.max(1, count);
  };

  let visibleCount = fitCount(offset);

  // If we’re so far to the right that we can’t fill visibleCount, pull offset left.
  // (This also fixes the “thinks it’s at the end too early” bug.)
  const maxOffset = Math.max(0, totalNavigableColumns - visibleCount);
  if (offset > maxOffset) {
    offset = maxOffset;
    visibleCount = fitCount(offset);
  }

  const startIndex = offset;
  const endIndex = Math.min(offset + visibleCount - 1, totalNavigableColumns - 1);

  const canGoLeft = startIndex > 0;
  const canGoRight = endIndex < totalNavigableColumns - 1;

  // 1-based labels, NOT including the pillar
  const labelStart = startIndex + 1;
  const labelEnd   = endIndex + 1;

  return {
    contentViewportPx,
    totalNavigableColumns,
    visibleCount,
    startIndex,
    endIndex,
    labelStart,
    labelEnd,
    canGoLeft,
    canGoRight
  };
}
```

**Key ideas**

* We subtract the pillar width up front. The pillar never affects the count.
* We cap to `targetSlots` (e.g., **2** in portrait). If columns are small, you still only show 2; if a column gets huge, `fitCount` falls back to **1**.
* We clamp `offset` so you can always reach the last column (fixes your “can’t reach 4–5” issue).
* Display labels are **1-based** and **exclude** the pillar: page 1 shows `1–2`, page 2 `2–3`, page 3 `3–4`, page 4 `4–5`.

---

### 2) How to use it

```ts
// EXAMPLE IN A REACT COMPONENT

const baseWidths: Record<ColumnId, number> = {
  KJV: 420,
  CrossRefs: 360,
  Prediction: 360,
  Fulfillment: 360,
  Verification: 360
};

function useColumnLayout({
  containerEl,       // ref to the scrolling container
  pillarEl,          // ref to the sticky ref/# column
  activeColumns,     // ['KJV','CrossRefs','Prediction',...]
  zoom,              // 1.0, 1.2, etc
  targetSlots,       // portrait: 2, landscape: 3+
  gapPx,             // your column gap
  offset,            // state
  setOffset          // setter
}: {
  containerEl: HTMLElement | null;
  pillarEl: HTMLElement | null;
  activeColumns: ColumnId[];
  zoom: number;
  targetSlots: number;
  gapPx: number;
  offset: number;
  setOffset: (n: number) => void;
}) {
  const [layout, setLayout] = React.useState<LayoutResult | null>(null);

  const recompute = React.useCallback(() => {
    if (!containerEl || !pillarEl) return;
    const containerWidthPx = Math.round(containerEl.getBoundingClientRect().width);
    const pillarWidthPx    = Math.round(pillarEl.getBoundingClientRect().width);

    const res = computeVisibleRange({
      containerWidthPx,
      pillarWidthPx,
      gapPx,
      activeColumns,
      baseWidths,
      zoom,
      targetSlots,
      offset
    });

    // If our offset got clamped, sync it
    if (res.startIndex !== offset) setOffset(res.startIndex);
    setLayout(res);
  }, [containerEl, pillarEl, activeColumns, zoom, targetSlots, gapPx, offset, setOffset]);

  React.useEffect(() => {
    recompute();
  }, [recompute]);

  // also listen to resize/orientation or zoom changes
  React.useEffect(() => {
    const onResize = () => recompute();
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
      window.removeEventListener('orientationchange', onResize);
    };
  }, [recompute]);

  return layout;
}
```

**Navigating:**

```ts
// when user clicks →
if (layout?.canGoRight) setOffset(layout.startIndex + 1);
// when user clicks ←
if (layout?.canGoLeft)  setOffset(layout.startIndex - 1);

// Display “x–y / N” (exclude pillar)
const label = layout ? `${layout.labelStart}-${layout.labelEnd} / ${layout.totalNavigableColumns}` : '';
```

---

### 3) DOM structure tip (prevents pillar from leaking into math)

If you currently keep the pillar inside the same horizontal scroller using `position: sticky`, it still contributes to `scrollWidth` and can “feel” like a column. The **cleanest** fix is splitting containers:

```html
<div class="grid">
  <aside class="pillar" ref={pillarRef}>…Ref/#…</aside>
  <section class="content" ref={containerRef}>
    <!-- horizontally paged columns go here -->
  </section>
</div>
```

```css
.grid {
  display: grid;
  grid-template-columns: auto 1fr; /* pillar | content */
  width: 100%;
}
.pillar {
  position: sticky;
  left: 0;
  z-index: 3;
}
.content {
  overflow: hidden; /* we page by offset, not a native scroll */
}
```

That way the pillar **never** enters the content width or navigation counts.

---

### 4) Why your numbers were “1–3, 2–4, 3–5”

Your old logic likely set `maxVisibleColumns = 3` (counting the pillar) and/or used the container’s full width without subtracting the pillar. The algorithm above fixes both by:

* subtracting `pillarWidthPx`,
* **capping** to `targetSlots` (2 for portrait),
* recalculating when zoom/size changes so a huge column becomes a **1-slot** page gracefully.

---

If you want, paste your current `maxVisibleColumns`/`offset` code and I’ll splice this straight into it with your exact variable names.
