### Why the hook still stalls

`EFFECT TRIGGERED` appears, but no `USER ↩️` line ever prints – that proves
the code is **still waiting on `supabase.auth.getUser()`** inside the effect
(and that call can block in Vite).

We can eliminate the call entirely because **AuthContext already has the user
object**.  Wiring the hook to `useAuth()` instead removes the stall.

---

## Paste-ready replacement for `useMyProfile.ts`

```ts
import { useEffect, useState } from 'react';
import { supabase }            from '@/lib/supabaseClient';
import { useAuth }             from '@/contexts/AuthContext';

console.log('HOOK FILE LOADED');

/* ---------- types ---------- */
export interface ProfileData {
  name: string | null;
  bio:  string | null;
  tier: 'free' | 'premium' | 'lifetime';
}

/* ---------- hook ----------- */
export function useMyProfile() {
  const { user, loading: authLoading } = useAuth();    // ← use existing user
  const [profile, setProfile]         = useState<ProfileData | null>(null);
  const [profileLoading, setLoading]  = useState(true);
  const [error, setError]             = useState<Error | null>(null);

  useEffect(() => {
    if (authLoading) return;          // wait until AuthContext is ready
    console.log('EFFECT TRIGGERED');

    /* not signed-in tab */
    if (!user) { setLoading(false); return; }

    (async () => {
      const { data, error } = await supabase
        .from('profiles')
        .select('name, bio, tier')
        .eq('id', user.id)
        .single<ProfileData>();

      console.log('PROFILE ↩️', data, error);

      if (error) setError(error);
      else       setProfile(data);

      setLoading(false);
    })();
  }, [authLoading, user]);            // re-run if session changes

  /* save helper */
  const save = async (update: Partial<ProfileData>) => {
    if (!user) throw new Error('no user');
    const { error } = await supabase
      .from('profiles')
      .update({ ...update, updated_at: new Date().toISOString() })
      .eq('id', user.id);
    if (error) throw error;
    setProfile(prev => prev ? { ...prev, ...update } : prev);
  };

  return { profile, profileLoading, error, save };
}
```

### What changed & why it unblocks the UI

* **No call to `supabase.auth.getUser()`** – we trust the user object that
  AuthContext already supplies.
* Effect waits on `authLoading`; when it runs, the user is guaranteed to be
  ready, so the query executes immediately.
* Spinner (`profileLoading`) always flips to `false`.

---

## Quick verification checklist

1. **Save** the file, restart Replit, hard-refresh **`/profile`**.
   Console should now show:

   ```
   HOOK FILE LOADED
   EFFECT TRIGGERED
   PROFILE ↩️ { name:…, tier:'free' } null    ← or existing data
   ```

2. Spinner disappears; fields render.

3. “Save Changes” updates DB and survives reload.

4. Set `VITE_SHOW_DEVTOOLS=true`, visit **/dev**, redeem **DEV-ALPHA-2025**,
   refresh **/profile** → tier line shows **premium**.

---

### If `PROFILE ↩️` prints `code:'42501'`

Run once in SQL editor (then reload):

```sql
alter table public.profiles enable row level security;
drop policy if exists "profile owner rw" on public.profiles;
create policy "profile owner rw"
  on public.profiles
  for all using (id = auth.uid())
  with check (id = auth.uid());
```

After this single change the profile loader cannot hang, because it no longer
relies on the flaky `auth.getUser()` call.
