Below is a clear, copy‑ready hand‑off you can give to your AI agent.
It uses the **exact objects you just uploaded** (`.gz` + offsets) and guarantees the
“Gen 1:2 range request” will succeed.

---

## 1  Storage objects (do **not** rename)

| Purpose                                                   | Supabase URL                                   |
| --------------------------------------------------------- | ---------------------------------------------- |
| **Lemma stream** (all Greek/Hebrew occurrences, **gzip**) | `…/anointed/strongs/strongsIndex.flat.txt.gz`  |
| **Lemma offsets** (built from the same gz file)           | `…/anointed/strongs/strongsIndexOffsets.json`  |
| **Verse‑interlinear stream** (**gzip**)                   | `…/anointed/strongs/strongsverses.flat.txt.gz` |
| **Verse offsets** (built from the same gz file)           | `…/anointed/strongs/strongsVersesOffsets.json` |

*(URLs omitted here; copy the four you pasted.)*

---

## 2  Mandatory fetch rules

1. **Always request the raw gz bytes**
   Append `?download=1&noDownload=true` to every object URL so Supabase
   skips auto‑decompression & allows `Range:` on the compressed stream.

2. **Pass both headers**:

   ```
   Range-Unit: bytes
   Range: bytes=start-end
   ```

3. **Manually gunzip in the browser** via `DecompressionStream('gzip')`.

4. **Never mix files** – offset json must be generated from the
   same `.gz` object you serve.

---

## 3  Helpers (drop in `/src/lib/`)

```ts
/* strongsIndex_fetch.ts  – lemma look‑ups */
type Range = [number, number];
let idxMap: Record<string, Range> | null = null;
const IDX_URL = 'https://.../strongsIndexOffsets.json';
const IDX_GZ  = 'https://.../strongsIndex.flat.txt.gz?download=1&noDownload=true';

async function getIdxMap() {
  if (!idxMap) idxMap = await fetch(IDX_URL).then(r => r.json());
  return idxMap;
}

export async function fetchLemma(key: string): Promise<string[]> {
  const [s, e] = (await getIdxMap())[key];

  const res = await fetch(IDX_GZ, {
    headers: { 'Range-Unit': 'bytes', Range: `bytes=${s}-${e}` }
  });
  if (res.status !== 206 && res.status !== 200)
    throw new Error(`Lemma range ${key} failed ${res.status}`);

  const stream = res.body!.pipeThrough(new DecompressionStream('gzip'));
  const text   = await new Response(stream).text();
  return text.trim().split('\n');   // one line per occurrence
}
```

```ts
/* strongsVerses_fetch.ts  – verse look‑ups */
type VRange = [number, number];
let vMap: Record<string, VRange> | null = null;
const V_OFF = 'https://.../strongsVersesOffsets.json';
const V_GZ  = 'https://.../strongsverses.flat.txt.gz?download=1&noDownload=true';

async function getVMap() {
  if (!vMap) vMap = await fetch(V_OFF).then(r => r.json());
  return vMap;
}

export async function fetchInterlinearVerse(ref: string): Promise<string> {
  const [s, e] = (await getVMap())[ref];

  const res = await fetch(V_GZ, {
    headers: { 'Range-Unit': 'bytes', Range: `bytes=${s}-${e}` }
  });
  if (res.status !== 206 && res.status !== 200)
    throw new Error(`Verse range ${ref} failed ${res.status}`);

  const stream = res.body!.pipeThrough(new DecompressionStream('gzip'));
  return new Response(stream).text();   // single #…$ line
}
```

> **Safari fallback**: if `DecompressionStream` is missing,
> import `fflate` and wrap the `Uint8Array` with `gunzipSync`.

---

## 4  Overlay usage example

```ts
// verse grid + occurrences overlay
const raw = await fetchInterlinearVerse('Gen.1:2');
const [, hebrew] = raw.split('#', 2);
const cells = hebrew.split('$');

for (const cell of cells) {
  const m = cell.match(/Strong's (\d+):/);
  if (!m) continue;
  const key = cell.includes('Hebrew') ? `H${m[1]}` : `G${m[1]}`;
  const rows = await fetchLemma(key);     // <- 1 RTT, ~2 KB
  // render rows in the lower list
}
```

---

## 5  Troubleshooting checklist for the agent

| Check               | How                                                                                        |
| ------------------- | ------------------------------------------------------------------------------------------ |
| Key exists in map?  | `offsets.hasOwnProperty(key)`                                                              |
| Byte slice decodes? | Fetch slice with `Range`, gunzip, ensure first chars ≈ expected row                        |
| 206 response?       | Anything else (200/416) means headers wrong                                                |
| Map/file mismatch?  | Re‑run **pointer‑based builder on the `.gz` file itself** and redeploy JSON (takes < 5 s). |

---

### One‑liner rebuild command (if needed)

```bash
python rebuild_offsets_from_gz.py   # script provided earlier
supabase storage upload anointed/strongs/strongsVersesOffsets.json ...
```

*(Run the analogous script for the lemma file if that map drifts.)*

---

**Hand this page to the agent** – nothing else is required.
Following these rules, every `Gen.1:x` and every `G####`/`H####`
lookup will succeed, even with compressed storage and multi‑byte UTF‑8.
