# Anointed.io – Membership & Billing (Supabase + Stripe) Pack

This is a complete, efficient, production‑ready package that wires **Supabase Auth + SQL/RLS** with **Stripe** for:

* 30‑day trial on signup (optional toggle)
* Paywall‑gated writes (read‑only when paused/canceled)
* Cancel at period end (keep access for the paid month)
* Continue (resume) within the paid month without new checkout
* Re‑subscribe after it ends (new Checkout)
* Customer Portal for PM updates and invoices
* Full delete‑my‑account (hard delete of data + stop billing)

All server logic runs in **Supabase Edge Functions** for simplicity/perf; the client calls those functions. You can copy/paste these files into your project and adjust env vars.

---

## 0) Environment variables

Add these in Supabase project settings → Functions → Env vars (and locally via `.env` for `supabase functions serve`).

```
SUPABASE_URL=<your supabase url>
SUPABASE_ANON_KEY=<your anon key>
SUPABASE_SERVICE_ROLE_KEY=<service role>
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
APP_URL=https://anointed.io  # or your local dev URL
STRIPE_PRICE_ID=price_12345  # your subscription price
TRIAL_DAYS=30                # set 0 to disable trials
```

---

## 1) SQL – schema, helpers, RLS

Create: **`supabase/sql/init_membership.sql`** and run in Supabase SQL editor.

```sql
-- PROFILES (Stripe state mirror)
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  stripe_customer_id text unique,
  subscription_status text check (
    subscription_status in (
      'trialing','active','past_due','paused','canceled','incomplete','incomplete_expired','unpaid'
    )
  ) default 'incomplete',
  current_period_end timestamptz,
  trial_end timestamptz,
  cancel_at timestamptz,
  updated_at timestamptz default now()
);

-- Trigger: insert profile on new auth user
create or replace function public.handle_new_user()
returns trigger language plpgsql security definer as $$
begin
  insert into public.profiles (user_id, email)
  values (new.id, coalesce(new.email, ''))
  on conflict (user_id) do nothing;
  return new;
end; $$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();

-- SUBSCRIPTIONS mirror (auditing)
create table if not exists public.subscriptions (
  id text primary key, -- stripe subscription id
  user_id uuid not null references auth.users(id) on delete cascade,
  status text not null,
  price_id text not null,
  product_id text not null,
  current_period_start timestamptz,
  current_period_end timestamptz,
  cancel_at timestamptz,
  canceled_at timestamptz,
  trial_start timestamptz,
  trial_end timestamptz,
  raw jsonb not null,
  created_at timestamptz default now()
);
create index if not exists subscriptions_user_id_idx on public.subscriptions (user_id);

-- Helper: membership gate (writes only if active/trialing and trial not expired)
create or replace function public.has_active_membership(u uuid)
returns boolean language sql stable as $$
  select case
    when p.subscription_status in ('active','trialing') then
      (p.subscription_status <> 'trialing') or (p.trial_end is null) or (p.trial_end > now())
    else false
  end
  from public.profiles p
  where p.user_id = u
$$;

-- View: flags for simple UI decisions
create or replace view public.membership_flags as
select
  p.user_id,
  p.subscription_status,
  p.trial_end,
  p.current_period_end,
  p.cancel_at,
  (p.subscription_status in ('active','trialing')
    and (p.subscription_status <> 'trialing' or p.trial_end > now())
  ) as is_active_now,
  (p.subscription_status = 'active' and p.cancel_at is not null and p.cancel_at > now()) as is_scheduled_to_cancel,
  (p.subscription_status not in ('active','trialing') or (p.subscription_status='trialing' and coalesce(p.trial_end, now() - interval '1 second') <= now())) as is_read_only
from public.profiles p;

-- RLS examples for notes/highlights (replicate pattern to other write tables)
alter table if exists public.notes enable row level security;

create policy if not exists "read own notes" on public.notes
for select using (user_id = auth.uid());

create policy if not exists "insert notes if active" on public.notes
for insert with check (user_id = auth.uid() and public.has_active_membership(auth.uid()));

create policy if not exists "update notes if active" on public.notes
for update using (user_id = auth.uid() and public.has_active_membership(auth.uid()))
with check (user_id = auth.uid() and public.has_active_membership(auth.uid()));

create policy if not exists "delete notes if active" on public.notes
for delete using (user_id = auth.uid() and public.has_active_membership(auth.uid()));

alter table if exists public.highlights enable row level security;

create policy if not exists "read own highlights" on public.highlights
for select using (user_id = auth.uid());

create policy if not exists "insert highlights if active" on public.highlights
for insert with check (user_id = auth.uid() and public.has_active_membership(auth.uid()));

create policy if not exists "update highlights if active" on public.highlights
for update using (user_id = auth.uid() and public.has_active_membership(auth.uid()))
with check (user_id = auth.uid() and public.has_active_membership(auth.uid()));

create policy if not exists "delete highlights if active" on public.highlights
for delete using (user_id = auth.uid() and public.has_active_membership(auth.uid()));
```

> Result: Paused/canceled users can still **read** their data, but **any write fails** automatically (RLS), which your UI catches and shows the reactivation prompt.

---

## 2) Edge Function – Stripe Webhook

Path: **`supabase/functions/stripe-webhook/index.ts`**

```ts
// deno-lint-ignore-file no-explicit-any
import { serve } from "https://deno.land/std/http/server.ts";
import Stripe from "https://esm.sh/stripe@14.0.0?target=deno";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, { apiVersion: "2024-06-20" });
const supabase = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET")!;

function mapStatus(s: string): string {
  switch (s) {
    case "trialing": return "trialing";
    case "active": return "active";
    case "past_due": return "past_due";
    case "canceled": return "canceled";
    case "unpaid": return "unpaid";
    case "incomplete": return "incomplete";
    case "incomplete_expired": return "incomplete_expired";
    default: return "paused"; // safety fallback
  }
}

async function upsertProfileFromSubscription(sub: any) {
  const customerId = sub.customer as string;
  const cust = await stripe.customers.retrieve(customerId) as any;
  const userId = sub.metadata?.user_id ?? cust?.metadata?.user_id;
  if (!userId) return;

  await supabase.from("profiles").upsert({
    user_id: userId,
    stripe_customer_id: customerId,
    subscription_status: mapStatus(sub.status),
    current_period_end: sub.current_period_end ? new Date(sub.current_period_end * 1000).toISOString() : null,
    trial_end: sub.trial_end ? new Date(sub.trial_end * 1000).toISOString() : null,
    cancel_at: sub.cancel_at ? new Date(sub.cancel_at * 1000).toISOString() : null,
    updated_at: new Date().toISOString()
  }, { onConflict: "user_id" });

  await supabase.from("subscriptions").upsert({
    id: sub.id,
    user_id: userId,
    status: sub.status,
    price_id: sub.items?.data?.[0]?.price?.id ?? "",
    product_id: sub.items?.data?.[0]?.price?.product ?? "",
    current_period_start: sub.current_period_start ? new Date(sub.current_period_start * 1000).toISOString() : null,
    current_period_end: sub.current_period_end ? new Date(sub.current_period_end * 1000).toISOString() : null,
    cancel_at: sub.cancel_at ? new Date(sub.cancel_at * 1000).toISOString() : null,
    canceled_at: sub.canceled_at ? new Date(sub.canceled_at * 1000).toISOString() : null,
    trial_start: sub.trial_start ? new Date(sub.trial_start * 1000).toISOString() : null,
    trial_end: sub.trial_end ? new Date(sub.trial_end * 1000).toISOString() : null,
    raw: sub
  });
}

serve(async (req) => {
  const sig = req.headers.get("Stripe-Signature");
  if (!sig) return new Response("Missing signature", { status: 400 });
  const body = await req.text();

  let event;
  try {
    event = stripe.webhooks.constructEvent(body, sig, webhookSecret);
  } catch (err) {
    return new Response(`Webhook signature verification failed: ${err}`, { status: 400 });
  }

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as any;
        if (session.mode === "subscription" && session.subscription) {
          const sub = await stripe.subscriptions.retrieve(session.subscription as string);
          await upsertProfileFromSubscription(sub);
        }
        break;
      }
      case "customer.subscription.created":
      case "customer.subscription.updated":
      case "customer.subscription.deleted": {
        const sub = event.data.object as any;
        await upsertProfileFromSubscription(sub);
        break;
      }
      case "invoice.payment_failed":
      case "invoice.paid": {
        const inv = event.data.object as any;
        if (inv.subscription) {
          const sub = await stripe.subscriptions.retrieve(inv.subscription as string);
          await upsertProfileFromSubscription(sub);
        }
        break;
      }
    }
    return new Response("ok", { status: 200 });
  } catch (e) {
    return new Response(`Webhook handler error: ${e}`, { status: 500 });
  }
});
```

**Deploy**: `supabase functions deploy stripe-webhook --no-verify-jwt`

In Stripe Dashboard → Developers → Webhooks, point to:

```
https://<your-project-ref>.functions.supabase.co/stripe-webhook
```

---

## 3) Edge Functions – membership actions

We expose four endpoints the client can call with the user’s JWT in `Authorization: Bearer <jwt>`.

Create a folder per function under `supabase/functions/` and deploy each.

### A) `membership-cancel` – cancel at period end

**`supabase/functions/membership-cancel/index.ts`**

```ts
// deno-lint-ignore-file no-explicit-any
import { serve } from "https://deno.land/std/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import Stripe from "https://esm.sh/stripe@14.0.0?target=deno";

serve(async (req) => {
  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const userClient = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_ANON_KEY")!, {
    global: { headers: { Authorization: req.headers.get("Authorization") ?? "" } }
  });
  const { data: { user }, error } = await userClient.auth.getUser();
  if (error || !user) return new Response("Unauthorized", { status: 401 });

  const admin = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
  const { data: subRow } = await admin
    .from("subscriptions").select("id,status").eq("user_id", user.id)
    .order("current_period_end", { ascending: false }).limit(1).single();
  if (!subRow) return new Response(JSON.stringify({ error: "No subscription" }), { status: 400 });

  const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, { apiVersion: "2024-06-20" });
  await stripe.subscriptions.update(subRow.id, { cancel_at_period_end: true });
  return new Response(JSON.stringify({ ok: true }), { status: 200 });
});
```

### B) `membership-continue` – undo scheduled cancel (resume)

**`supabase/functions/membership-continue/index.ts`**

```ts
import { serve } from "https://deno.land/std/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import Stripe from "https://esm.sh/stripe@14.0.0?target=deno";

serve(async (req) => {
  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const userClient = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_ANON_KEY")!, {
    global: { headers: { Authorization: req.headers.get("Authorization") ?? "" } }
  });
  const { data: { user } } = await userClient.auth.getUser();
  if (!user) return new Response("Unauthorized", { status: 401 });

  const admin = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
  const { data: subRow } = await admin
    .from("subscriptions").select("id,status").eq("user_id", user.id)
    .order("current_period_end", { ascending: false }).limit(1).single();
  if (!subRow) return new Response(JSON.stringify({ error: "No subscription" }), { status: 400 });

  const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, { apiVersion: "2024-06-20" });
  await stripe.subscriptions.update(subRow.id, { cancel_at: null, cancel_at_period_end: false });
  return new Response(JSON.stringify({ ok: true }), { status: 200 });
});
```

### C) `membership-resubscribe` – create Checkout after end

**`supabase/functions/membership-resubscribe/index.ts`**

```ts
// deno-lint-ignore-file no-explicit-any
import { serve } from "https://deno.land/std/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import Stripe from "https://esm.sh/stripe@14.0.0?target=deno";

serve(async (req) => {
  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const userClient = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_ANON_KEY")!, {
    global: { headers: { Authorization: req.headers.get("Authorization") ?? "" } }
  });
  const { data: { user } } = await userClient.auth.getUser();
  if (!user) return new Response("Unauthorized", { status: 401 });

  const admin = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
  const { data: profile } = await admin.from("profiles").select("stripe_customer_id").eq("user_id", user.id).single();

  const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, { apiVersion: "2024-06-20" });
  const trialDays = Number(Deno.env.get("TRIAL_DAYS") ?? "0");

  const session = await stripe.checkout.sessions.create({
    mode: "subscription",
    line_items: [{ price: Deno.env.get("STRIPE_PRICE_ID")!, quantity: 1 }],
    customer: profile?.stripe_customer_id || undefined,
    customer_creation: profile?.stripe_customer_id ? undefined : "always",
    metadata: { user_id: user.id },
    success_url: `${Deno.env.get("APP_URL")}/app`,
    cancel_url: `${Deno.env.get("APP_URL")}/subscribe?canceled=1`,
    subscription_data: trialDays > 0 ? { trial_period_days: trialDays } : undefined
  });

  return new Response(JSON.stringify({ url: session.url }), { status: 200, headers: { "Content-Type": "application/json" } });
});
```

### D) `membership-portal` – open Stripe Customer Portal

**`supabase/functions/membership-portal/index.ts`**

```ts
import { serve } from "https://deno.land/std/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import Stripe from "https://esm.sh/stripe@14.0.0?target=deno";

serve(async (req) => {
  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const userClient = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_ANON_KEY")!, {
    global: { headers: { Authorization: req.headers.get("Authorization") ?? "" } }
  });
  const { data: { user } } = await userClient.auth.getUser();
  if (!user) return new Response("Unauthorized", { status: 401 });

  const admin = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
  const { data: profile } = await admin.from("profiles").select("stripe_customer_id").eq("user_id", user.id).single();

  const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, { apiVersion: "2024-06-20" });
  const portal = await stripe.billingPortal.sessions.create({
    customer: profile!.stripe_customer_id,
    return_url: `${Deno.env.get("APP_URL")}/account`
  });

  return new Response(JSON.stringify({ url: portal.url }), { status: 200, headers: { "Content-Type": "application/json" } });
});
```

### E) `delete-account` – hard delete user + cancel subs

**`supabase/functions/delete-account/index.ts`**

```ts
// deno-lint-ignore-file no-explicit-any
import { serve } from "https://deno.land/std/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import Stripe from "https://esm.sh/stripe@14.0.0?target=deno";

serve(async (req) => {
  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const userClient = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_ANON_KEY")!, {
    global: { headers: { Authorization: req.headers.get("Authorization") ?? "" } }
  });
  const { data: { user } } = await userClient.auth.getUser();
  if (!user) return new Response("Unauthorized", { status: 401 });

  const admin = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
  const { data: profile } = await admin.from("profiles").select("stripe_customer_id").eq("user_id", user.id).single();

  // Cancel all subs (safety) before deleting
  if (profile?.stripe_customer_id) {
    const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, { apiVersion: "2024-06-20" });
    const subs = await stripe.subscriptions.list({ customer: profile.stripe_customer_id, status: "all" });
    for (const s of subs.data) {
      if (s.status !== "canceled") await stripe.subscriptions.cancel(s.id);
    }
  }

  // If app tables don't have ON DELETE CASCADE, delete manually here
  // await admin.from("highlights").delete().eq("user_id", user.id);
  // await admin.from("notes").delete().eq("user_id", user.id);

  // Delete auth user (this cascades profiles via FK)
  const { error: derr } = await admin.auth.admin.deleteUser(user.id);
  if (derr) return new Response(`Delete failed: ${derr.message}`, { status: 500 });

  return new Response("Deleted", { status: 200 });
});
```

**Deploy all:**

```
supabase functions deploy stripe-webhook --no-verify-jwt
supabase functions deploy membership-cancel
supabase functions deploy membership-continue
supabase functions deploy membership-resubscribe
supabase functions deploy membership-portal
supabase functions deploy delete-account
```

---

## 4) Client integration (minimal)

Use the Supabase JS client in your app. For each action, POST to the function with the user’s JWT.

```ts
// auth.ts – get current session JWT
import { createClient } from "@supabase/supabase-js";
export const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!);
export async function getJwt() {
  const { data } = await supabase.auth.getSession();
  return data.session?.access_token ?? "";
}

// callFunction.ts – helper to call edge functions
export async function callFn(name: string, body?: unknown): Promise<any> {
  const token = await getJwt();
  const res = await fetch(`${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/${name}`, {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: body ? JSON.stringify(body) : undefined
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json().catch(() => ({}));
}
```

### Payments Panel (React pseudo)

```tsx
import { useEffect, useState } from "react";
import { supabase } from "./auth";
import { callFn } from "./callFunction";

export function PaymentsPanel() {
  const [flags, setFlags] = useState<any>(null);
  useEffect(() => {
    supabase.from("membership_flags").select("*").single().then(({ data }) => setFlags(data));
  }, []);
  if (!flags) return null;

  const go = async (fn: string) => {
    const res = await callFn(fn);
    if (res.url) window.location.href = res.url; else window.location.reload();
  };

  return (
    <section>
      {flags.is_active_now && !flags.is_scheduled_to_cancel && (
        <div>
          <p>Membership is active. Next bill: {new Date(flags.current_period_end).toLocaleString()}</p>
          <button onClick={() => go("membership-portal")}>Manage payment method</button>
          <button onClick={() => go("membership-cancel")}>Cancel at period end</button>
        </div>
      )}

      {flags.is_active_now && flags.is_scheduled_to_cancel && (
        <div>
          <p>Ends on {new Date(flags.cancel_at).toLocaleString()} unless you continue.</p>
          <button onClick={() => go("membership-continue")}>Continue subscription</button>
          <button onClick={() => go("membership-portal")}>Manage payment method</button>
        </div>
      )}

      {flags.is_read_only && (
        <div>
          <p>Your membership ended. You can still view your notes. Re‑subscribe to keep building.</p>
          <button onClick={() => go("membership-resubscribe")}>Re‑subscribe</button>
          <button onClick={() => go("membership-portal")}>View invoices / update card</button>
        </div>
      )}
    </section>
  );
}
```

### Checkout button (signup / subscribe page)

```ts
// create initial Checkout for new user
await callFn("membership-resubscribe"); // uses TRIAL_DAYS to include a 30d trial if desired
```

---

## 5) Signup / Auth flow

1. User signs up (email/password or magic link) → Supabase trigger creates `profiles` row.
2. Redirect to **Subscribe** screen with a “Start membership” (Checkout) button → calls `membership-resubscribe`.
3. Webhook updates `profiles`/`subscriptions`. App reads `membership_flags` → unlocks.

> If you want "trial without PM": set `TRIAL_DAYS=30` and configure your Price to not require upfront PM. On trial end, Stripe will emit `invoice.payment_failed`/`incomplete`; your RLS flips the app to read‑only.

---

## 6) Test checklist

1. New user → Checkout → success → `profiles.subscription_status='active'` or `trialing`.
2. Writes to `notes` succeed while active/trialing.
3. Cancel at period end → `cancel_at` set, still active.
4. Continue (resume) → `cancel_at` cleared; still active.
5. Let period end → `status='canceled'` → app read‑only; writes fail.
6. Re‑subscribe → Checkout again → status returns to active.
7. Payment failure → webhook flips to `past_due` → read‑only.
8. Delete account → all rows removed + Stripe subs canceled.

---

## Why this is efficient

* **RLS as the gate**: You don’t run custom middle‑tier checks per write; the DB enforces state. Simple and fast.
* **Edge Functions only**: No extra server to deploy; fewer moving parts.
* **Minimal Stripe calls**: Only on explicit actions or webhooks.
* **Single source of truth**: `profiles` drives both UI and RLS automatically.

> Your engineer can lift this pack as‑is. Swap IDs/URLs, deploy functions, run the SQL, and wire the two UI components. That’s it.
