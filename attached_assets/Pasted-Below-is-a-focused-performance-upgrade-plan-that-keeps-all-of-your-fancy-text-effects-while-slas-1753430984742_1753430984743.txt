Below is a focused **performance‚Äêupgrade plan** that keeps all of your fancy text effects while slashing memory and CPU cost so two, three, or even all ten labels can be on without bogging the browser.

---

## 1‚ÄÇWhy it explodes now

| Current step                                                                            | Hidden cost                                                                                                                                                                                  |
| --------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Per‚Äëcharacter `Set` array** (`Array(text.length)` storing `Set<LabelName>` or `null`) | \~80‚ÄØbytes *per char* when two labels overlap (array slot + Set obj + Map entry) ‚Üí a 250‚Äëchar verse ‚âà‚ÄØ20‚ÄØKB. 40 on‚Äëscreen verses = **0.8‚ÄØMB** every render, multiplied each time you scroll. |
| **Set objects per char**                                                                | Garbage collector must traverse thousands of tiny objects ‚Üí jank.                                                                                                                            |
| **Regex rebuilt every render**                                                          | `new RegExp()` in a loop recreates the same state; CPU wasted.                                                                                                                               |

---

## 2‚ÄÇReplace **Sets** with a **10‚Äëbit mask**

You have 10 labels ‚áí they fit in a single `uint16`.
*Enums ‚Üí bit positions*:

```ts
export enum LabelBits {
  who        = 1 << 0,
  what       = 1 << 1,
  when       = 1 << 2,
  where      = 1 << 3,
  command    = 1 << 4,
  action     = 1 << 5,
  why        = 1 << 6,
  seed       = 1 << 7,
  harvest    = 1 << 8,
  prediction = 1 << 9,
}
export type LabelMask = number;          // 0‚Äë1023
```

*Memory impact:* one **char‚Äëflag** now costs **2¬†bytes**, not an object.

---

## 3‚ÄÇCompute **ranges once**, not per char

### 3‚ÄëA‚ÄÇCompile regexes at load time

```ts
const regexCache: Record<string /*trans+label*/, RegExp[]> = {};

function compileRegexes(tCode: string, label: keyof typeof LabelBits, phrases: string[]) {
  const key = `${tCode}:${label}`;
  if (regexCache[key]) return regexCache[key];
  regexCache[key] = phrases.map(ph =>
    new RegExp(ph.replace(/[.*+?^${}()|[\]\\]/g,'\\$&').replace(/\s+/g,'\\W+'), 'gi')
  );
  return regexCache[key];
}
```

### 3‚ÄëB‚ÄÇSweep‚Äëline ‚Äúinterval merge‚Äù per verse

Instead of a char array:

```ts
interface Seg { start:number; end:number; mask:LabelMask; }   // [start,end)

function computeSegments(
  verse: string,
  tCode: string,
  vKey: string,
  activeMask: LabelMask
): Seg[] {
  // 1. collect intervals
  const events: {pos:number; bit:LabelMask; add:boolean}[] = [];
  for (const [name, bit] of Object.entries(LabelBits)) {
    if (!(activeMask & bit)) continue;                       // label not toggled
    const phrases = getLabel(tCode, vKey, name as any);
    const regs    = compileRegexes(tCode, name as any, phrases);
    regs.forEach(re => {
      let m:RegExpExecArray|null;
      while ((m = re.exec(verse))) {
        events.push({ pos:m.index,           bit, add:true  });
        events.push({ pos:m.index+m[0].length, bit, add:false });
      }
    });
  }

  if (!events.length) return [{ start:0, end:verse.length, mask:0 }];

  // 2. sort & sweep
  events.sort((a,b)=>a.pos-b.pos || (a.add? -1:+1)); // add before remove
  const segs:Seg[] = [];
  let depth:LabelMask = 0, last = 0;
  for (const {pos,bit,add} of events) {
    if (pos>last) segs.push({ start:last, end:pos, mask:depth });
    depth = add ? (depth | bit) : (depth & ~bit);
    last  = pos;
  }
  if (last<verse.length) segs.push({ start:last, end:verse.length, mask:depth });
  return segs;
}
```

*Characteristics:*

* **O(matches¬†log‚ÄØm)**, minimal GC, and the output is just an array of 3‚Äëfield structs (tiny).

### 3‚ÄëC‚ÄÇMemoize per (translation, verseKey, activeMask)

```ts
const segCache = new Map<string /*t|v|mask*/, Seg[]>();

function getSegmentsCached(tCode:string,vKey:string,verse:string,mask:LabelMask){
  const key = `${tCode}|${vKey}|${mask}`;
  let seg = segCache.get(key);
  if (!seg){
    seg = computeSegments(verse,tCode,vKey,mask);
    segCache.set(key,seg);
  }
  return seg;
}
```

Evict old entries (e.g., keep last 500) with a tiny LRU if you wish.

---

## 4‚ÄÇRender spans with **class bit‚Äëmapping**

### 4‚ÄëA‚ÄÇMap mask to class string (fast)

```ts
const bitToClass: Record<LabelMask,string> = {
  [LabelBits.who]:        'fx-hand',
  [LabelBits.what]:       'fx-shadow',
  [LabelBits.when]:       'fx-under',
  [LabelBits.where]:      'fx-bracket',
  [LabelBits.command]:    'fx-bold',
  [LabelBits.action]:     'fx-ital',
  [LabelBits.why]:        'fx-outline',
  [LabelBits.seed]:       'sup-seed',
  [LabelBits.harvest]:    'sup-harvest',
  [LabelBits.prediction]: 'sup-predict',
};

function classesFor(mask:LabelMask){
  let cls='';
  for(const [bit,str] of Object.entries(bitToClass)){
    if(mask & Number(bit)) cls += str+' ';
  }
  return cls.trim();
}
```

### 4‚ÄëB‚ÄÇRenderer

```tsx
const VerseRow:React.FC<RowProps> = ({ verseKey, verseText }) => {
  const { activeMask, activeTranslation } = useBigCtx();  // activeMask = OR of bits
  const segs = useMemo(
    () => getSegmentsCached(activeTranslation, verseKey, verseText, activeMask),
    [activeTranslation, verseKey, verseText, activeMask],
  );

  return (
    <>
      {segs.map((s,i)=>(
        s.mask
          ? <span key={i} className={classesFor(s.mask)}>{verseText.slice(s.start,s.end)}</span>
          : verseText.slice(s.start,s.end)
      ))}
    </>
  );
};
```

‚ñ∂ **No per‚Äëchar data**, **no `Set` objects**, one memoized array per verse+mask.

---

## 5‚ÄÇOptional turbo boosts

| Tactic                                      | How / When                                                                                               |
| ------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **Off‚Äëthread pre‚Äëcompute**                  | Kick `computeSegments` into a Web¬†Worker (Comlink). The main thread just renders cached results.         |
| **Debounce toggle**                         | Wrap the menu click in `setTimeout(()=> setMask(m),0)` so the UI paints before the heavy compute starts. |
| **IntersectionObserver + throttled worker** | Only send verses actually entering view to the worker queue; skip those still off‚Äëscreen.                |
| **Typed¬†arrays**                            | Store `events` in `Uint32Array` if you ever profile regex as the new bottleneck.                         |

---

## 6‚ÄÇCSS: single wrapper is enough

Because each bit maps to a class you no longer need nested spans:

```css
/* combine-able utilities */
.fx-hand     { font-family:'Homemade Apple','Bradley Hand',cursive; }
.fx-shadow   { text-shadow:2px 2px 3px rgba(0,0,0,.25); }
.fx-under    { text-decoration:underline; }
.fx-bold     { font-weight:700; }
.fx-ital     { font-style:italic; }
.fx-outline  { -webkit-text-stroke:1px currentColor; text-shadow:
                1px 0 0,currentColor,-1px 0 0,currentColor,0 1px 0,currentColor,0 -1px 0,currentColor; }
.fx-bracket::before { content:'[' }  .fx-bracket::after { content:']' }
.sup-seed::after     { content:'*'; }   /* etc. */
```

Multiple classes on the same element layer perfectly (e.g., `class="fx-hand fx-shadow fx-under"`).

---

## 7‚ÄÇWhat this delivers

| Metric (typical 300‚Äëchar verse) | Before              | After                   |
| ------------------------------- | ------------------- | ----------------------- |
| Per‚Äëverse RAM with 2 labels     | \~20‚ÄØKB             | **<‚ÄØ2‚ÄØKB**              |
| GC objects per verse            | 300+ `Set`s         | **0**                   |
| Regex instances                 | rebuilt each render | **cached once**         |
| Main‚Äëthread work on toggle      | freezes at 2 labels | **smooth at 10 labels** |

Even on low‚Äëend mobile, two‚Äëfinger scrolls remain 60‚ÄØfps.

---

### üí°‚ÄØYour next commit message

> ‚ÄúSwitch label overlay engine to bitmask+segment model; memory cut 90‚ÄØ%, toggles at 10‚ÄØlabels now instant. Cached compiled regex, single‚Äëspan renderer, ready for worker offload.‚Äù

Copy the snippets, slot them in place of your current per‚Äëcharacter `Set` logic, and watch the site fly.
