hey agent we are adding in all of the columns that supabase is going to need for all of this data and all of the forums, can you implement these properly, you already have all the secrets. we are going to need to collect usernames now at sign up, so update that sign up overlay please
---

# 2) Replit agent: exact tasks + endpoints

Tell your Replit agent to implement these **three** endpoints using Node (Express) with `@supabase/supabase-js`:

### Environment

```
SUPABASE_URL=...
SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_ROLE_KEY=...   # server-side only
```

### Install

```
npm i express @supabase/supabase-js zod
```

### `lib/supabase.ts`

```ts
import { createClient } from '@supabase/supabase-js';

export const supabaseClient = createClient(
  process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!
);

export const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { autoRefreshToken: false, persistSession: false } }
);
```

### 2.1 Check username availability

`GET /api/auth/username-available?u=<handle>`

```ts
import express from 'express';
import { supabaseAdmin } from './lib/supabase';
import { z } from 'zod';

const router = express.Router();
const schema = z.string().min(3).max(24).regex(/^[A-Za-z0-9_]+$/);

router.get('/api/auth/username-available', async (req, res) => {
  try {
    const u = String(req.query.u || '').trim();
    const parsed = schema.safeParse(u);
    if (!parsed.success) return res.json({ ok: true, available: false, reason: 'invalid' });

    const { data, error } = await supabaseAdmin
      .rpc('username_available', { u });
    if (error) throw error;
    return res.json({ ok: true, available: !!data });
  } catch (e:any) {
    return res.status(500).json({ ok: false, error: e.message });
  }
});

export default router;
```

### 2.2 Sign up (email + password + username)

* We set `user_metadata.username` & `display_name` at creation time so the **trigger** fills `public.profiles` immediately.
* Choose whether email confirmation is required in Supabase Auth settings. If you want immediate access during testing, set “Confirm email” off (you can turn it on later).

`POST /api/auth/signup`

```ts
import express from 'express';
import { supabaseClient } from './lib/supabase';
import { z } from 'zod';

const router = express.Router();

const bodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  username: z.string().min(3).max(24).regex(/^[A-Za-z0-9_]+$/),
  displayName: z.string().max(80).optional()
});

router.post('/api/auth/signup', async (req, res) => {
  try {
    const { email, password, username, displayName } = bodySchema.parse(req.body);

    // Client-side precheck (optional; server double-checks via DB constraint anyway)
    // You can call /username-available first in the UI, but we'll just try signup:
    const { data, error } = await supabaseClient.auth.signUp({
      email, password,
      options: { data: { username, display_name: displayName ?? username } }
    });
    if (error) return res.status(400).json({ ok: false, error: error.message });

    // If email confirmation is ON, data.user will exist but session is null until they confirm.
    return res.json({ ok: true, userId: data.user?.id ?? null, needsConfirmation: !data.session });
  } catch (e:any) {
    return res.status(400).json({ ok: false, error: e.message });
  }
});

export default router;
```

### 2.3 Complete profile (optional endpoint to update username/display name later)

`POST /api/profile/update`

```ts
import express from 'express';
import { supabaseClient } from './lib/supabase';
import { z } from 'zod';

const router = express.Router();
const schema = z.object({
  username: z.string().min(3).max(24).regex(/^[A-Za-z0-9_]+$/).optional(),
  displayName: z.string().max(80).optional(),
  avatarUrl: z.string().url().optional()
});

router.post('/api/profile/update', async (req, res) => {
  try {
    // require user session (Bearer token from client)
    const authHeader = req.headers.authorization || '';
    const accessToken = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;
    if (!accessToken) return res.status(401).json({ ok:false, error:'missing token' });

    const supa = supabaseClient; // same project; the token is validated by row policies
    supa.auth.setAuth(accessToken);

    const { username, displayName, avatarUrl } = schema.parse(req.body);

    const updates: any = {};
    if (typeof username === 'string') updates.username = username;
    if (typeof displayName === 'string') updates.display_name = displayName;
    if (typeof avatarUrl === 'string') updates.avatar_url = avatarUrl;

    if (!Object.keys(updates).length) return res.json({ ok: true });

    const { data, error } = await supa
      .from('profiles')
      .update(updates)
      .eq('id', (await supa.auth.getUser()).data.user?.id)
      .select('id')
      .single();

    if (error) return res.status(400).json({ ok:false, error: error.message });
    return res.json({ ok:true });
  } catch (e:any) {
    return res.status(400).json({ ok:false, error: e.message });
  }
});

export default router;
```

### Server bootstrap (example)

```ts
import express from 'express';
import usernameAvail from './username-available';
import signup from './signup';
import profileUpdate from './profile-update';

const app = express();
app.use(express.json());

app.use(usernameAvail);
app.use(signup);
app.use(profileUpdate);

app.get('/healthz', (_, res) => res.send('ok'));
app.listen(3000, () => console.log('API up on :3000'));
```

---

# 3) Frontend flow (quick)

1. **Sign Up form**: email, password, username, display name (optional).
2. On blur of username field → call `/api/auth/username-available?u=…` for green check.
3. Submit → `POST /api/auth/signup`.

   * If `needsConfirmation: true`, show “check your email”.
   * If email confirmations are off, they’ll be logged in immediately.
4. After auth → call `/api/profile/update` if they change handle/display later.

*Note:* Your RLS already prevents forum posting without premium; you can keep that while still requiring a username for future posting via the policies we added earlier (or add them later).

---

# 4) Stripe (later)

No change now. When approved, your webhook will just flip `subscription_status/premium_until` and your existing policies immediately unlock posting.

---

## Test checklist (2 minutes)

* Create new user via `/api/auth/signup` → check `public.profiles` row with `username` set.
* Try to set a duplicate username → should get 409-ish/constraint error.
* `select public.username_available('somehandle')` → true/false as expected.
* Public profile view returns handle + avatar, **no email**:
  `select * from public.public_profiles limit 5;`

If you want me to bundle any of the forum “must-have-username-to-post” policies right now, say the word and I’ll hand you the exact block (it’ll just add `public.has_handle()` to your existing forum write policies).
