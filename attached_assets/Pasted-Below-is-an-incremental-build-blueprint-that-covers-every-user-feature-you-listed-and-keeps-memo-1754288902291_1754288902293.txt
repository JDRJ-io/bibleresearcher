Below is an **incremental-build blueprint** that covers every user feature you listed and keeps memory / bandwidth lean.  You can ship each box independently and nothing conflicts with what’s live today.

| # | Feature                                          | Where it lives                          | Core idea                                                                                                                                                     | Payload size per user (rough) |
| - | ------------------------------------------------ | --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------- |
| 1 | **Return-to-last-place** <br>(+ 10-step history) | **`localStorage`** (client only)        | A 60-second debounced `saveState()` that stores `{ anchorIndex, scrollX, history:[…] }`. On sign-in you read it once and jump.                                | ≤ 200 bytes                   |
| 2 | **Notes autosave**                               | **`notes` table** (already created)     | `<textarea>` writes to state; `useEffect` with *500 ms debounce + blur* calls `update(id,text)`. Cell gets `overflow-y:auto` so the verse table never grows.  | what the user types           |
| 3 | **Bookmarks**                                    | **`bookmarks` table** (already created) | Button calls `insert({ index_value, name, color })`. Table already enforces one row per user; helper column isn’t required.                                   | \~80 B per bookmark           |
| 4 | **Highlights** (portion of verse text)           | **`highlights` table** (new, see SQL)   | On text-selection you capture offsets (`start`, `end`) **within that translation’s string** and store one row. Render by wrapping `<span class="hl h-{id}">`. | 40 B per highlight            |
| 5 | **Theme-adaptive colors**                        | **CSS variables**                       | Store highlight color in HSL; when the user switches theme you run `adapt(color, theme)` client-side → sets `--hl-<id>` var so contrasts remain WCAG-AA.      | n/a                           |

Below are the implementation details you can copy-paste.

---

## 1 · Lightweight “save state”

```ts
// hooks/useReadingState.ts
import { useEffect, useRef } from 'react';
import { useVerseNav } from '@/hooks/useVerseNav';

export function useReadingState() {
  const { anchorIndex } = useVerseNav();
  const historyRef = useRef<number[]>(JSON.parse(localStorage.getItem('history') ?? '[]'));

  /* restore on mount */
  useEffect(() => {
    const saved = JSON.parse(localStorage.getItem('readingState') ?? 'null');
    if (saved) window.requestAnimationFrame(() =>
      document.querySelector('#v-scroll')!.scrollTo({ top: saved.scrollY })
    );
  }, []);

  /* debounced autosave every 60 s */
  useEffect(() => {
    const t = setInterval(() => {
      /* 1️⃣ push anchor into 10-item history */
      historyRef.current = [anchorIndex, ...historyRef.current.filter(i => i !== anchorIndex)].slice(0,10);
      localStorage.setItem('history', JSON.stringify(historyRef.current));

      /* 2️⃣ save current scroll & col scroll */
      localStorage.setItem('readingState', JSON.stringify({
        anchorIndex,
        scrollY: document.querySelector('#v-scroll')!.scrollTop,
        scrollX: document.querySelector('#h-scroll')!.scrollLeft,
      }));
    }, 60_000);
    return () => clearInterval(t);
  }, [anchorIndex]);
}
```

*Call `useReadingState()` once in `BiblePage.tsx`; no DB traffic, zero RLS.*

---

## 2 · Notes autosave (UX already in screenshot)

*You already wired `useNotes()` — add debounce so users never press “Save”.*

```tsx
const [draft, setDraft] = useState(note?.text ?? '');
useDebouncedEffect(
  () => updateNote(note.id, draft),          // from useNotes hook
  [draft],
  500                                        // ms
);

<textarea
  value={draft}
  onChange={e => setDraft(e.target.value)}
  placeholder="Add your note here…"
/>
```

CSS:

```css
.notes-cell textarea {
  width: 100%;
  height: 100px;
  resize: vertical;
  overflow-y: auto;
}
```

---

## 3 · Bookmark helper

```ts
export function useBookmarkActions() {
  const { anchorIndex } = useVerseNav();
  const { user } = useAuth();

  async function saveBookmark(name: string, color = '#FFD700') {
    return supabase.from('bookmarks').insert({
      user_id: user?.id,
      name,
      index_value: anchorIndex,
      color,
    });
  }
  return { saveBookmark };
}
```

Add “Save position” button→prompt name→call `saveBookmark()`.

---

## 4 · Highlights (SQL + minimal hook)

### Capture selection

```ts
function onMouseUp(e) {
  const sel = window.getSelection();
  if (!sel || sel.isCollapsed) return;

  const verseEl = sel.anchorNode!.closest('[data-verse-ref]');
  if (!verseEl) return;
  const verseRef = verseEl.getAttribute('data-verse-ref')!;
  const translation = verseEl.getAttribute('data-translation')!;

  const start = sel.anchorOffset;
  const end   = sel.focusOffset;

  openColorWheel(async (hsl) => {
    await supabase.from('highlights').insert({
      verse_ref: verseRef,
      translation,
      start: Math.min(start,end),
      end:   Math.max(start,end),
      color_hsl: hsl,            // 'h s% l%'
    });
    /* optimistically add <span class="hl ..."> to DOM */
  });
}
```

### Render

```tsx
verseText.split('').map((ch,i) =>
  <span key={i} style={{ background:
     highlightAt(i) ? `hsl(var(--h${highlightAt(i)}))` : 'transparent' }}>
     {ch}
  </span>
)
```

`highlightAt(i)` returns `highlight.id` if `start ≤ i < end`.

---

## 5 · Theme-adaptive color

```ts
function adapt(hsl: string, theme: 'dark'|'light') {
  const [h,s,l] = hsl.split(' ').map(Number);         // crude parse
  return theme === 'dark' ? `hsl(${h} ${s}% ${Math.min(l+30, 95)}%)`
                          : `hsl(${h} ${s}% ${Math.max(l-30, 15)}%)`;
}

useEffect(() => {
  highlights.forEach(hl => {
    document.documentElement.style.setProperty(`--h${hl.id}`,
      adapt(hl.color_hsl, currentTheme));
  });
}, [highlights, currentTheme]);
```

Now every highlight automatically re-tints when the theme flips.

---

### Roll-out order I’d recommend

1. **Drop `useReadingState()`** – gives instant “resume where I left”.
2. **Add debounce to notes** – no schema changes needed.
3. **Hook up bookmarks** – table already exists.
4. **Run `highlights` SQL** → add selection listener & simple render.
5. Later: replace textarea with **TipTap** for rich notes, and swap the color-wheel for your preferred UI library.

Feel free to ping me with a specific step if something doesn’t compile or a query errors out — each block above is isolated so we can debug one at a time. Happy building!


await supabase.from('highlights').insert({
  verse_ref:  'Gen.1:3',
  translation:'KJV',
  start_pos:  12,
  end_pos:    24,
  color_hsl:  '210 80% 60%',
});
