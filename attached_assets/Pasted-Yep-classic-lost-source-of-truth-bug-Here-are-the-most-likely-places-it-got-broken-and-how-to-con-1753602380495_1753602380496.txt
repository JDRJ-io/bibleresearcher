Yep—classic “lost source-of-truth” bug. Here are the most likely places it got broken and how to confirm/fix each fast:

⸻

1. Two “main translations” in play

Symptom: header updates, text doesn’t.

Where it happens:
You now have both:
	•	const { main } = useTranslationMaps() (store-driven) and
	•	a mainTranslation prop passed down (or captured in a closure).

If the store changes but the prop/closure doesn’t, you render the wrong one.

Fix: pick ONE source of truth (store). At the top of VirtualRow:

const mainTranslation = useBibleStore(s => s.translationState.main);

Stop passing a mainTranslation prop from parents, or vice-versa—just one path.

⸻

2. Memoized column config not tracking mainTranslation

slotConfig / visibleColumns is likely built in a useMemo without mainTranslation in its deps, so the header re-computes (because some other state changed) but the cell body still uses stale translation in a closure.

Fix: Ensure any useMemo/useCallback that touches mainTranslation lists it in the dependency array. Or abandon memoization for that small object—cheap to rebuild.

⸻

3. MainTranslationCell not remounting

React reuses the component; internal caches (verse text, segments) stay. Add a key:

<MainTranslationCell
  key={`${verse.reference}-${mainTranslation}`}
  …
/>

This forces a clean render when translation changes.

⸻

4. getVerseText / verse cache keyed wrong

Check getVerseText(ref, tCode) returns stale KJV because:
	•	It defaults to "KJV" if cache miss.
	•	Translation cache map uses upper/lower mismatch ("kjv" vs "KJV").
	•	The text for the newly selected translation was never fetched.

Fix:
Normalize tCode (toUpperCase()) everywhere and log:

console.debug('getVerseText', ref, tCode, !!cache[tCode]?.[ref])

If false, load it or show a skeleton.

⸻

5. Hook misuse during the refactor

You earlier moved useViewportLabels into VirtualRow. Good. Make sure you did not keep the old prop getVerseLabels anywhere—if a child still uses the prop, it may reference the old translation.

Search for getVerseLabels: across the project; ensure there’s only one provider.

⸻

6. Worker/cache keyed by the wrong tCode

You added normaliseTCode(); confirm the call to ensureLabelCacheLoaded(mainTranslation, …) uses the new mainTranslation, not a stale variable captured in a parent component.

⸻

Quick “diff-free” debugging script

In MainTranslationCell render:

console.log('CELL CHECK', {
  verse: verse.reference,
  mainTranslation,
  text: verseText?.slice(0,40),
  cacheHas: Boolean(window.textCache?.[mainTranslation]?.[verse.reference])
});

If mainTranslation changes but text/cacheHas don’t, it’s #1/#2/#3 above.

⸻

Action list for your agent
	1.	Unify source: grab mainTranslation from store ONLY; stop prop-drilling it.
	2.	Add key to MainTranslationCell.
	3.	Fix memo deps (include mainTranslation).
	4.	Normalize tCode in all text/label cache lookups.
	5.	Remove leftover getVerseLabels props—use the hook result.
	6.	Trim logs (they hide real issues and cost time).

Do those and the main translation will switch both the text and the label file seamlessly again. Ping me if one still doesn’t flip—I’ll look at the next log snippet.