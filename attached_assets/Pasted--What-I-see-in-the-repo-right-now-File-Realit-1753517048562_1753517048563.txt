### What I see in the repo right now

| File                                              | Reality                                                                                                              | What should be there                                                            |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| **`client/src/components/bible/LabeledText.tsx`** | Still the **old stub** that accepts **`text + mask + segmentKey`** and never touches `labelData` or `activeLabels`.  | The new five‑prop version that calls **`useLabeledText`** and adds CSS classes. |
| **`client/src/hooks/useLabeledText.ts`**          | **Does not exist** in the tree Replit shows.                                                                         | Required – performs the sweep‑line algorithm and returns segments.              |
| **`client/src/lib/labelRenderer.ts`**             | Present and OK.                                                                                                      | ✓                                                                               |
| **`VirtualRow.tsx`**                              | Already passing the new props (`text`, `labelData`, `activeLabels`, …).                                              | ✓                                                                               |

Because the build still picks up the old stub, React renders plain text → nothing happens in the UI, even though the Worker, cache, and hooks all fire.

---

### 90‑second unblock checklist

1. **Delete the stub completely**

   ```bash
   rm client/src/components/bible/LabeledText.tsx
   ```

2. **Create the correct component in the *same* path**

   ```tsx
   // client/src/components/bible/LabeledText.tsx
   import React from 'react';
   import { useLabeledText } from '@/hooks/useLabeledText';
   import { classesForMask } from '@/lib/labelRenderer';

   interface Props {
     text: string;
     labelData: Record<string, string[]>;
     activeLabels: string[];
     verseKey: string;
     translationCode: string;
   }

   export default function LabeledText({
     text,
     labelData,
     activeLabels,
     verseKey,
   }: Props) {
     const segs = useLabeledText(text, labelData, activeLabels as any);

     return (
       <>
         {segs.map((s) => {
           const cls = classesForMask(s.mask);
           const key = `${verseKey}-${s.start}-${s.mask}`;
           return cls ? (
             <span key={key} className={cls}>
               {text.slice(s.start, s.end)}
             </span>
           ) : (
             text.slice(s.start, s.end)
           );
         })}
       </>
     );
   }
   ```

3. **Add the missing hook**

   ```tsx
   // client/src/hooks/useLabeledText.ts
   import { useMemo } from 'react';
   import { LabelBits } from '@/lib/labelBits';

   export interface Segment { start: number; end: number; mask: number; }

   export function useLabeledText(
     text: string,
     labelData: Record<string, string[]>,
     activeLabels: (keyof typeof LabelBits)[]
   ): Segment[] {
     return useMemo(() => {
       if (!text || activeLabels.length === 0) {
         return [{ start: 0, end: text.length, mask: 0 }];
       }
       type Ev = { pos: number; bit: number; add: boolean };
       const evs: Ev[] = [];
       activeLabels.forEach(lbl => {
         const bit = LabelBits[lbl];
         (labelData?.[lbl] || []).forEach(ph => {
           const re = new RegExp(
             ph.replace(/[.*+?^${}()|[\]\\]/g,'\\$&').replace(/\s+/g,'\\W+'),
             'gi'
           );
           let m:RegExpExecArray|null;
           while ((m = re.exec(text))) {
             evs.push({ pos:m.index, add:true,  bit });
             evs.push({ pos:m.index+m[0].length, add:false, bit });
           }
         });
       });
       if (!evs.length) return [{ start:0, end:text.length, mask:0 }];
       evs.sort((a,b)=>a.pos-b.pos||(a.add?-1:1));
       const segs:Segment[] = [];
       let mask = 0, last = 0;
       for (const {pos,bit,add} of evs) {
         if (pos>last) segs.push({ start:last, end:pos, mask });
         mask = add ? (mask|bit) : (mask&~bit);
         last = pos;
       }
       if (last<text.length) segs.push({ start:last, end:text.length, mask });
       return segs;
     }, [text, JSON.stringify(labelData), activeLabels.join()]);
   }
   ```

4. **Restart the dev server** (Replit “Run” button or `npm run dev`) so Vite/Next clears the old module from cache.

5. **Toggle a label** (“Who”, “What”…).
   *Expected:* in DevTools → Elements you’ll now see spans like

   ```html
   <span class="fx-hand">God</span>
   ```

   and the visual effect (cursive font) appears.

---

### Sanity‐check steps if it still “does nothing”

| Test                                                                      | What you should see                        |
| ------------------------------------------------------------------------- | ------------------------------------------ |
| Console log inside `MainTranslationCell` (“shouldUseLabeledText: true …”) | **true** when a label is active.           |
| In Elements panel, search for “`fx-hand`”                                 | Nodes should appear inside verse cells.    |
| Network tab after second toggle                                           | **0 B** transferred (file already cached). |
| Chrome Memory snapshot after scroll                                       | Heap stable under \~5 MB.                  |

If you pass step 1–3 above and still don’t see highlights, the only remaining culprit is the CSS file not loaded. Make sure one global import exists:

```ts
// e.g. in App.tsx or index.css
import '@/styles/label-effects.css';
```

Once the stub is removed and the hook+component are in place, the overlay system finally renders—and it will keep the low‑memory, single‑fetch behaviour we designed.
