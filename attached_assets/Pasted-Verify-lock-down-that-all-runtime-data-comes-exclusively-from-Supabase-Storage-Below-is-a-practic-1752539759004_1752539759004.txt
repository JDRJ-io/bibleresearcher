Verify & lock-down that all runtime data comes exclusively from Supabase Storage

Below is a practical checklist plus one small code-instrumentation patch to prove (and keep proving) that nothing is calling /api/* or any other stray endpoint.

⸻

1  Hard-code the canonical bucket paths in BibleDataAPI

Make sure every path builder lives in this one file:

// src/data/BibleDataAPI.ts
const BUCKET = 'anointed';

const paths = {
  translation:  (id: string) => `translations/${id}.txt`,
  crossRef:     (set: 'cf1' | 'cf2') => `references/${set}.txt`,
  prophecyRows: 'references/prophecy_rows.txt',
  prophecyIdx:  'references/prophecy_index.json',
  verseKeys:    'metadata/verseKeys-canonical.json',
};

export async function fetchFromStorage(path: string) {
  const { data, error } = await supabase
    .storage
    .from(BUCKET)
    .download(path);

  if (error) throw new Error(`Supabase load failed → ${path}: ${error.message}`);
  return await data.text();                 // or .arrayBuffer() for workers
}

All public helpers (e.g. getTranslation, getCrossRef) call fetchFromStorage.

⸻

2  Instrument one global fetch-guard (dev only)

Add this once in src/main.tsx right after you import polyfills:

if (import.meta.env.DEV) {
  const originalFetch = window.fetch;
  window.fetch = (...args) => {
    const url = typeof args[0] === 'string' ? args[0] : args[0]?.url;
    if (url && url.includes('/api/references/')) {
      console.error('🚨  stray fetch to /api route:', url);
      throw new Error('stray /api reference fetch');
    }
    return originalFetch(...args);
  };
}

Dev build will now throw immediately if any leftover code tries /api/references/*.

⸻

3  Search-and-destroy stray endpoints

Run these two commands in Replit’s shell:

grep -R "/api/references" src || echo "✅ no /api references"
grep -R "fetch(" src | grep -v "Supabase" | grep -v "BibleDataAPI" | grep -v "http(s)://" 

	•	First should return nothing.
	•	Second should list only BibleDataAPI.fetchFromStorage calls or test mocks.

⸻

4  Worker round-trip test

// Somewhere in VirtualBibleTable, dev-only
if (import.meta.env.DEV) {
  crossWorker.postMessage({ type: 'ping' });
  crossWorker.onmessage = (e) => {
    if (e.data !== 'pong') console.error('Worker protocol mismatch');
  };
}

In the worker:

self.onmessage = (e) => {
  if (e.data.type === 'ping') self.postMessage('pong');
};

Guarantees main thread is in control and worker never self-fetches data.

⸻

5  Network-tab smoke test (manual)
	1.	Dev build (pnpm dev)
	2.	Switch main translation, add two alternates, scroll 1000 rows.
	3.	In DevTools > Network filter by anointed bucket.
	•	You should see signed URLs only under https://<project-id>.supabase.co/storage/v1/object/public/anointed/...
	•	No /api or localhost routes fetching data files.

⸻

6  CI guard

Add to validate-architecture.sh

if grep -R "/api/references" src; then
  echo "❌ stray /api/references path found" && exit 1
fi

CI will fail any future PR that re-introduces those endpoints.

⸻

7  Confirm log cleanliness in prod build

pnpm build
serve -s dist    # or your deploy preview
# open browser > DevTools > Console
# interact with app – expect zero “stray fetch” or CORS errors



⸻

If everything above passes, all data now flows:

Supabase Storage  →  BibleDataAPI (single facade, single cache)
                   ↘ workers via postMessage
                   ↘ React components via useVerseText selector

and nothing depends on /api/references or duplicate caches.

Give this checklist to your Replit agent; once the fetch-guard shows a clean run and CI guard passes, you can be confident every byte is sourced from Supabase storage only.