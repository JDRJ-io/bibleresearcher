You need two things your code doesn’t currently do:
	1.	Push a history entry every time you jump to a verse.
	2.	Listen for popstate (browser back/forward OR your back button) and re-scroll to that verse.

Here’s a drop-in pattern that fits your anchor-centered virtual table.

⸻

1. A tiny navigation hook

// hooks/useVerseNav.ts
import { useEffect, useRef } from 'react';
import { ROW_HEIGHT } from '@/constants/layout';
import { getVerseKeys } from '@/lib/verseKeysLoader';

type ScrollToFn = (ref: string) => void;

export function useVerseNav(scrollToVerse: ScrollToFn) {
  const verseKeys = getVerseKeys();                 // already in your project
  const lastPushed = useRef<string | null>(null);   // avoid duplicate pushes

  // Call this when a link is clicked
  const goTo = (ref: string) => {
    // Normalize ref if you have dot/space formats
    const norm = ref.trim();
    if (norm && norm !== lastPushed.current) {
      window.history.pushState({ ref: norm }, '', `#${norm}`);
      lastPushed.current = norm;
    }
    scrollToVerse(norm);
  };

  // Handle back/forward (or manual history.back())
  useEffect(() => {
    const onPop = (e: PopStateEvent) => {
      const ref = (e.state && e.state.ref) || window.location.hash.slice(1);
      if (ref) {
        scrollToVerse(ref);
        lastPushed.current = ref; // keep sync
      }
    };
    window.addEventListener('popstate', onPop);
    return () => window.removeEventListener('popstate', onPop);
  }, [scrollToVerse]);

  return { goTo };
}



⸻

2. Your existing scroll function (reuse it!)

You already have logic in columnData.onVerseClick to scroll to a verse. Extract it into a utility so both the hook and anywhere else can call it:

// utils/scrollToVerse.ts
import { ROW_HEIGHT } from '@/constants/layout';
import { getVerseKeys } from '@/lib/verseKeysLoader';

export function makeScrollToVerse(container: HTMLDivElement | null) {
  const verseKeys = getVerseKeys();

  return (ref: string) => {
    if (!container) return;
    const idx = verseKeys.findIndex(k => k === ref || k.replace(/\./g,' ') === ref || k.replace(/\s/g,'.') === ref);
    if (idx === -1) return;

    const containerH = container.clientHeight;
    const target = (idx * ROW_HEIGHT) - (containerH / 2) + (ROW_HEIGHT / 2);

    container.scrollTo({ top: Math.max(0, target), behavior: 'auto' });

    // optional flash
    setTimeout(() => {
      const el = document.querySelector(`[data-verse-ref="${ref}"]`) as HTMLElement | null;
      if (el) {
        el.classList.add('verse-highlight-flash');
        setTimeout(() => el.classList.remove('verse-highlight-flash'), 400);
      }
    }, 25);
  };
}



⸻

3. Wire it in VirtualBibleTable.tsx

// inside VirtualBibleTable
const wrapperRef = useRef<HTMLDivElement>(null);

// create the scroller once
const scrollToVerse = useMemo(
  () => makeScrollToVerse(wrapperRef.current),
  []
);

// build nav hook
const { goTo } = useVerseNav(scrollToVerse);

// replace your old onVerseClick in columnData:
const columnData = {
  ...,
  onVerseClick: (ref: string) => goTo(ref),
};

And keep your back arrow button simple:

<button onClick={() => window.history.back()} aria-label="Back">
  ←
</button>

(Forward button = window.history.forward())

⸻

4. Common gotchas (fix now)
	•	Don’t use replaceState when following links—use pushState so the back button has somewhere to go.
	•	Normalize refs (spaces vs dots). Store the normalized value in state and hash so your lookups are deterministic.
	•	Avoid duplicate entries: the lastPushed ref check stops pushing the same verse twice in a row.
	•	Hash or query param? Hash is fine; if you ever switch to wouter/React Router, use their navigate but still call history.pushState to keep native back working.
	•	Virtualization & anchor: If the verse isn’t mounted yet, your slice loader will mount it after scroll. The flash highlight runs after a timeout to allow mounting.

⸻

That’s it: one hook, one scroll util, and your own back button just calls history.back(). Let me know if you want it integrated with wouter’s useLocation instead of hash states.