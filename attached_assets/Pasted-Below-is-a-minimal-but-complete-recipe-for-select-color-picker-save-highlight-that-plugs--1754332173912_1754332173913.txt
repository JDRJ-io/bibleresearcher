Below is a **minimal but complete recipe** for “select → color-picker → save
highlight” that plugs straight into the schema we created earlier
(`highlights` table with `verse_ref`, `translation`, `start_pos`, `end_pos`,
`color_hsl`).  You can paste-in the pieces one-by-one and see the overlay
appear within minutes.

---

## ①  Mark the render target

In the JSX where you print the *main translation* text for every verse,
wrap the string in a span that carries data attributes:

```tsx
/* VirtualRow.tsx (inside case 'main-translation') */
<span
  data-verse-ref={verse.ref}        /* Gen.15:14 */
  data-translation={mainTranslation}/* 'KJV'      */
  className="verse-text"
  onMouseUp={handleMouseUp}
>
  {verse.text}                      {/* plain string */}
</span>
```

No highlight logic inside the row itself—just expose metadata and forward
`onMouseUp`.

---

## ②  Global selection handler

Create a *single* listener (e.g. in `HighlightProvider.tsx`) so you don’t
duplicate work per row.

```tsx
// hooks/useHighlightCapture.ts
import { useEffect, useState } from 'react';

export function useHighlightCapture(onSelect: (info: SelectionInfo) => void) {
  useEffect(() => {
    function handleMouseUp() {
      const sel = window.getSelection();
      if (!sel || sel.isCollapsed) return;

      // Ensure selection starts *inside* a verse-text span
      const anchorEl = sel.anchorNode?.parentElement;
      if (!anchorEl?.classList.contains('verse-text')) return;

      const verseRef   = anchorEl.dataset.verseRef!;
      const translation = anchorEl.dataset.translation!;
      const start = sel.anchorOffset;
      const end   = sel.focusOffset;

      // Normalize direction
      const [s, e] = start < end ? [start, end] : [end, start];

      // Absolute coords for color wheel
      const rect = sel.getRangeAt(0).getBoundingClientRect();
      const pos  = { x: rect.left + rect.width / 2, y: rect.top - 8 };

      onSelect({ verseRef, translation, startPos: s, endPos: e, pos });
      sel.removeAllRanges();          // collapse selection
    }
    document.addEventListener('mouseup', handleMouseUp);
    return () => document.removeEventListener('mouseup', handleMouseUp);
  }, [onSelect]);
}

export interface SelectionInfo {
  verseRef: string;
  translation: string;
  startPos: number;
  endPos: number;
  pos: { x: number; y: number };      // screen coords
}
```

---

## ③  Color-wheel overlay

```tsx
// components/HighlightToolbar.tsx
import { motion } from 'framer-motion';
import { supabase } from '@/lib/supabaseClient';
import { useAuth } from '@/contexts/AuthContext';

const colors = ['210 80% 60%', '10  90% 60%', '120 70% 45%', '280 70% 65%'];

export function HighlightToolbar({ sel, onClose }: {
  sel: SelectionInfo | null;
  onClose: () => void;
}) {
  const { user } = useAuth();
  if (!sel) return null;

  async function save(col: string) {
    await supabase.from('highlights').insert({
      user_id:     user?.id,
      verse_ref:   sel.verseRef,
      translation: sel.translation,
      start_pos:   sel.startPos,
      end_pos:     sel.endPos,
      color_hsl:   col,
    });
    onClose();
  }

  return (
    <motion.div
      className="fixed z-50 flex gap-2 p-2 rounded-xl bg-zinc-800 shadow"
      style={{ left: sel.pos.x, top: sel.pos.y }}
      initial={{ opacity: 0, scale: .8 }} animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: .8 }}
    >
      {colors.map(c => (
        <button
          key={c}
          className="w-5 h-5 rounded-full"
          style={{ background: `hsl(${c})` }}
          onClick={() => save(c)}
        />
      ))}
    </motion.div>
  );
}
```

---

## ④  Provider to glue it together

```tsx
// contexts/HighlightContext.tsx
import { createContext, useState } from 'react';
import { AnimatePresence } from 'framer-motion';
import { useHighlightCapture, SelectionInfo } from '@/hooks/useHighlightCapture';
import { HighlightToolbar } from '@/components/HighlightToolbar';

export const HighlightProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [sel, setSel] = useState<SelectionInfo | null>(null);
  useHighlightCapture(setSel);

  return (
    <>
      {children}
      <AnimatePresence>
        <HighlightToolbar sel={sel} onClose={() => setSel(null)} />
      </AnimatePresence>
    </>
  );
};
```

Wrap your `<App />` tree in `<HighlightProvider>` once.

---

## ⑤  Render saved highlights

When you render verse text, split around highlight ranges and wrap spans:

```tsx
import { useVerseHighlights } from '@/hooks/useVerseHighlights'; // simple SWR hook

function VerseText({ verseRef, translation, text }: Props) {
  const hl = useVerseHighlights(verseRef, translation); // [{start_pos,end_pos,color_hsl}, …]

  if (!hl.length) return text;

  const parts: React.ReactNode[] = [];
  let cursor = 0;
  hl.forEach(h => {
    if (cursor < h.start_pos) parts.push(text.slice(cursor, h.start_pos));
    parts.push(
      <span key={cursor} style={{ background: `hsl(${h.color_hsl})` }}>
        {text.slice(h.start_pos, h.end_pos)}
      </span>
    );
    cursor = h.end_pos;
  });
  if (cursor < text.length) parts.push(text.slice(cursor));
  return <>{parts}</>;
}
```

*(Sort `hl` by `start_pos` first.)*

---

### Quick checklist to test

1. **Login**
2. Select a few words in the KJV column → color wheel pops just above.
3. Click a color → overlay fades, text becomes highlighted.
4. Refresh page → highlight persists (loaded from Supabase).
5. Another user signs in → sees only their own highlights (RLS).

That’s the full loop: capture, choose color, save, and render—all tied to your existing `highlights` table.  Adjust CSS, colors, or animation as you like and you’re golden.
