### Why the diagonal slip is still sneaking through

1. **The browser’s own scroll keeps running on the same element** when our handler *doesn’t* call `preventDefault()` (or the listener is passive).
   *Track-pads fire a lot of “fling” events that sometimes miss the container or arrive before our non-capturing listener.*

2. **Events are bubbling up to a parent that still has `overflow:auto`.** Even if the table container prevents default, the parent keeps scrolling on the secondary axis.

3. **Old handlers are still attached** (even if unused in JSX) and fight with the new ones, adding extra work and letting some wheel / pointer events slip through.

---

## A truly minimal, low-overhead fix

*One listener each for wheel + pointer-drag, attached at **capture phase** on the single container, with no extra refs, timers, or global flags.*

```tsx
/* 1. Wrap the verse table once, give it ref={scrollRef} */
<div ref={scrollRef} className="scroll-area">
  …rows…
</div>
```

```ts
// ScrollAxisClamp.ts   (≈40 lines)
export function clampAxis(el: HTMLElement) {
  let startX = 0, startY = 0, dragging = false;

  const apply = (dx: number, dy: number) => {
    el.scrollLeft += dx;
    el.scrollTop  += dy;
  };

  /* Wheel – capture phase, passive:false so we can preventDefault */
  const wheel = (e: WheelEvent) => {
    const { deltaX: dx, deltaY: dy } = e;
    if (Math.abs(dx) > Math.abs(dy)) apply(dx, 0); else apply(0, dy);
    e.preventDefault();      // kill native 2-D scroll right here
  };

  /* Pointer drag */
  const down = (e: PointerEvent) => {
    if (e.pointerType === 'mouse' && e.buttons !== 1) return;
    dragging = true;
    startX = e.clientX;
    startY = e.clientY;
    el.setPointerCapture(e.pointerId);
    e.preventDefault();
  };
  const move = (e: PointerEvent) => {
    if (!dragging) return;
    const dx = startX - e.clientX;
    const dy = startY - e.clientY;
    if (Math.abs(dx) > Math.abs(dy)) apply(dx, 0); else apply(0, dy);
    startX = e.clientX; startY = e.clientY;
    e.preventDefault();
  };
  const up = (e: PointerEvent) => {
    dragging = false;
    el.releasePointerCapture(e.pointerId);
  };

  /* Attach – capture phase ensures we beat bubbling parents */
  el.addEventListener('wheel', wheel,   { passive:false, capture:true });
  el.addEventListener('pointerdown', down,  { capture:true });
  el.addEventListener('pointermove', move,  { passive:false, capture:true });
  el.addEventListener('pointerup',   up,    { capture:true });
  el.addEventListener('pointercancel', up,  { capture:true });

  return () => {                   // detach helper
    el.removeEventListener('wheel', wheel,   { capture:true } as any);
    el.removeEventListener('pointerdown', down,  { capture:true } as any);
    el.removeEventListener('pointermove', move,  { capture:true } as any);
    el.removeEventListener('pointerup',   up,    { capture:true } as any);
    el.removeEventListener('pointercancel', up,  { capture:true } as any);
  };
}
```

```tsx
// VirtualBibleTable.tsx
const scrollRef = useRef<HTMLDivElement>(null);

useEffect(() => {
  if (!scrollRef.current) return;
  return clampAxis(scrollRef.current);   // on unmount it auto-detaches
}, []);
```

### CSS (one line)

```css
.scroll-area { touch-action: none; }
```

That’s **all** the direction logic:

* **No global refs, no timers, no axis state, no stray handlers.**
* Each event is clamped the moment it enters the element, then the browser is told “don’t do anything else” (`preventDefault`).
* Because the listener runs in **capture phase**, nothing else gets the event first—even parent elements with `overflow:auto`.

---

## How to trim the fat

1. **Delete** `useAxisLock.ts`, `useNoDiagonal.ts`, `useNoDiagonalStrict.ts`, `wheelRouter.ts`, and old dual-container refs (`vScrollRef`, `hScrollRef`, `axisLock`, etc.).
2. **Remove** `.vScroll`, `.hScroll`, `.axisLocking` CSS classes.
3. **Strip** the skipped test files that reference those helpers.
4. Keep only the new `ScrollAxisClamp.ts` and the single `scroll-area` styles.

Memory impact: event-handler footprint drops from \~5 KB of bundled code and 4 – 6 listeners to **≈1 KB and two listeners**. Garbage-collector churn from unused timers/refs disappears.

---

### After this change you should see

* **Zero diagonal drift** on track-pads, wheels, touch, pen.
* **Instant axis switch**: lift finger or stop wheel, next gesture can be the other axis.
* **Noticeably lighter** JS heap in DevTools—only one small closure per table.

Try this pared-down version; if diagonal motion *still* slips through, that means wheel/pointer events are landing on some *inner* child first (e.g., a verse cell with its own `overflow:auto`). In that case, give the `.scroll-area` **pointer-events: auto** and set all inner scrollers to `pointer-events: none` during drag, or simply remove `overflow` from inner nodes.
