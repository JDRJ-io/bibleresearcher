### 📜 Implementation Map (road‑to‑production)

| Layer                | What you already have                                            | Key files                                                                                | Next integration step                                                             |
| -------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **Front‑end shell**  | React 18 + Vite + Tailwind, virtualised verse table              | `main.tsx`, `App.tsx`, `VirtualBibleTable.tsx`, `VirtualRow.tsx`                         | keep bundle ≤ 2 MB (gzip) and ship PWA build via `npm run build`                  |
| **State / stores**   | Zustand slices + TanStack Query cache for server state           | `translationSlice.ts`, `useBibleData.ts`, `useAnchorSlice.ts`, `useQueueSync.ts`         | finish migrating legacy imports to the new slices; persist size/column prefs      |
| **Data façade**      | **Single gateway** `BibleDataAPI.ts` (all network I/O)           | façade itself + loaders `translationLoader.ts`, `verseKeysLoader.ts`, `prophecyCache.ts` | forbid raw `fetch` elsewhere (ESLint already configured)                          |
| **Workers**          | Translation, search & cross‑ref parsing off‑thread               | `translationWorker.js`, `searchWorker.js`, `crossReferencesWorker.ts`                    | move heavy parsing (e.g. prophecy) to workers to keep main thread < 50 ms         |
| **Offline layer**    | Workbox SW, Dexie `offlineDB.ts`, queued sync                    | `sw.ts`, `queueSync.ts`, `PWA_IMPLEMENTATION.md`                                         | verify Background Sync queue & translation cache guard rails pass the check‑list  |
| **UI slot grid**     | 20 numbered slots, sticky headers, column drag/resize            | `UI_layout_spec.md`, `ColumnHeaders.tsx`, `VirtualRow.tsx`                               | finish wiring Cross‑Refs (slot 2) & Prophecy P/F/V (slots 17‑19) columns          |
| **Supabase storage** | Immutable texts, offsets & user RPC endpoints                    | `DATA_STORAGE_MAP.md`                                                                    | upload new translations → no SW change; keep bucket map up‑to‑date                |
| **Testing & CI**     | Jest unit invariants, Cypress e2e (anchor, offline, auth)        | `*.test.ts`, `*.cy.js`, GitHub CI script                                                 | add failing test reproducing the `.split()` crash before you fix it               |
| **Docs**             | Architecture one‑pager, file & storage maps, behaviour contracts | `ARCHITECTURE_OVERVIEW.md`, `FILE_CONNECTIONS_MAP.md`, …                                 | keep in `/docs` and ship with repo for new contributors                           |

---

### 🔧 Immediate implementation tasks

1. **Finish slot‑config single‑source‑of‑truth**
   *Ensure `ColumnHeaders.tsx` & `VirtualRow.tsx` both consume ONE exported `slotConfig` constant; avoid divergent ad‑hoc objects.*

2. **Wire data columns that are “present but blank”**
   *Cross‑reference loader is ready in `BibleDataAPI.getCrossRefSlice()`; map it to `CrossReferencesCell` (slot 2). Prophecy TSV parsing is cached—render the P/F/V dots (slots 17‑19).*

3. **Hook up translation toggles**
   *`MainTranslationSelector.tsx` and `AlternateTranslationSelector.tsx` already mutate `translationSlice`; ensure the slice invalidates TanStack Query caches so newly‑shown verses appear instantly.*

4. **PWA polish** – run the validation matrix in **PWA\_IMPLEMENTATION.md** (offline load ≤ 2 s, update‑toast, cache eviction).

5. **Bundle guard** – keep `npm run bundle-check` green (< 2 MB gzip) by tree‑shaking debug code once the split bug is solved.

---