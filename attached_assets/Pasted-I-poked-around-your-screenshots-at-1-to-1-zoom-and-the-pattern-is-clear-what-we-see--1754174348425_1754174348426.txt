I poked around your screenshots at 1-to-1 zoom and the pattern is clear:

| what we see                                                                                       | why it happens                                                                                                                                                                                                                      |
| ------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Header “#” strip is \~-4 px narrower than the body “Gen 1:1” strip in both desktop and phone.** | The body cells are being **rotated 90°** (or `writing-mode: vertical-rl`) so their *logical height* becomes the *rendered width*. Because the header is still in the normal flow, the two boxes are measured by **different axes**. |
| **Gap gets larger on the phone.**                                                                 | Your portrait rule set swaps to a *different* CSS variable (`--mobile-ref-width`?) for the data cells, but the header keeps using the landscape variable.                                                                           |

In other words, it’s not a mysterious flex-gap—it’s the orientation math: one element’s “width” is the other element’s “height.”

---

## One-time sanity test

Add a temporary outline so the mismatch jumps out:

```css
.column-header-cell[data-column="reference"],
.cell-ref { outline: 1px dashed red !important; }
```

You’ll see (a) the header outline grows horizontally, (b) the cell outline grows vertically and then rotates into place.

---

## Fix in two steps

1. **Make both elements reference the *same physical dimension*** for every breakpoint:

```css
/* variables chosen once per breakpoint */
:root {
  --ref-col-w: 76px;           /* desktop landscape */
}

@media (max-width: 639px) {    /* portrait */
  :root { --ref-col-w: 94px; } /* allow for larger vertical label */
}

/* apply everywhere */
.column-header-cell[data-column="reference"],
.cell-ref {
  flex: 0 0 var(--ref-col-w);
  width: var(--ref-col-w);     /* for grid / table-layout */
  max-width: var(--ref-col-w);
  box-sizing: border-box;
}
```

Because both header **and** body now key off the exact same `--ref-col-w`, orientation can’t throw them out of sync.

2. **Give the header the same rotation flow** (or none at all).

   *Option A – keep it horizontal but reserve the rotated width*
   Works if you’re happy with the little “#” staying upright:

   ```css
   .column-header-cell[data-column="reference"] {
     display: flex;
     align-items: center;
     justify-content: center;
     /* no rotation */
   }
   ```

   *Option B – rotate the “#” too*
   Forces identical writing-mode, so computed boxes are literally the same:

   ```css
   .column-header-cell[data-column="reference"] {
     writing-mode: vertical-rl;   /* or transform: rotate(-90deg) translateX(-100%) */
     transform-origin: top left;
   }
   ```

   (If you rotate, add `white-space: nowrap; font-size: .75rem;` so the hash stays tiny.)

---

### Why it felt random before

Your SCSS/utility stack does:

```css
.cell-ref       { writing-mode: vertical-rl; width: var(--mobile-ref-width); }
.column-header  { width: var(--adaptive-ref-width); }   /* different var */
@media (...) { :root { --mobile-ref-width: 90px } }     /* only body picks this up */
```

So on orientation change the body width flips from `--adaptive-ref-width` → `--mobile-ref-width` (good), but the header is **still listening to the old variable** (bad).  Unifying on one custom property fixes the leak forever.

---

## Quick checklist for every column

1. Pick **one** custom property per column (`--col-ref`, `--col-main`, …).
2. Set it in your breakpoint blocks (`:root { … }`).
3. Use it for **both** header and body via `width | flex-basis | max-width`.
4. If you rotate text, rotate the header too or reserve the exact rotated width.
5. Keep `box-sizing: border-box; padding: 0; border-right: 1px solid …` identical.

Do that and the headers will sit dead-flush with their columns in portrait, landscape, or anything in between—no more “slightly off” slivers.
