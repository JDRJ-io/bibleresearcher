Why the original anointed.io prototype could show “the whole Bible” immediately without blowing up the heap
Technique	Where it appears in the old file	Effect
1. Single, fixed‑height placeholder container
verseContainerEl.style.height = totalRows * ROW_HEIGHT	setCurrentVerseArray() 	Allocates only one element (the container) to give the browser an exact scrollbar equal to the full length of Scripture. No verses are rendered yet.
2. Absolute positioning for each row
row.style.top = index * ROW_HEIGHT + "px"	createRowElement() 	Lets every row live anywhere inside that tall container without affecting neighbouring nodes, so you can “teleport” the same 100 row elements as the user scrolls.
3. Virtual‑window loop
for (i = start; i ≤ end; i++) … plus early‑exit guard
if (clampedStart === currentStart && clampedEnd === currentEnd) return;	updateVisibleRows() 	Keeps only ~120 rows (visible ± buffer) in the DOM at any moment; memory stays < 200 MB even with many columns.
4. Cheap jump links
IDs are generated once – Gen.1:1 → Gen_1_1 – and hyperlinks merely call scrollToVerse() which computes index * ROW_HEIGHT and scrolls	makeClickableRef() + scrollToVerse() 	A link never forces extra DOM; it just scrolls the viewport to the pre‑computed Y‑offset.

Together these four rules mean:

The browser only paints what you see.

The heap never stores 31 000 live rows at once, so it stays lightweight.

The scrollbar is perfect because the container’s height equals rows × ROW_HEIGHT.

Hyperlinks hit the exact verse because the Y‑position is deterministic.

Checklist to replicate this behaviour in your current (v‑3) repo
Restore the placeholder height

js
Copy
verseContainerEl.style.height = (totalRows * ROW_HEIGHT) + "px";
Do this immediately after you switch between canonical/chronological arrays.

Make every .verse-row absolutely positioned

css
Copy
.verse-row{
  position:absolute;
  height:var(--row-height-base);  /* e.g. 120 px */
  left:0; right:0;
}
Re‑introduce the early‑exit guard (it was removed during one merge):

js
Copy
if (clampedStart === currentStartIndex &&
    clampedEnd   === currentEndIndex) return;
Never touch innerHTML outside the virtual‑window loop.
Each time you change columns, theme, etc., call

js
Copy
currentStartIndex = 0;
currentEndIndex   = -1;
verseContainerEl.innerHTML = "";
updateVisibleRows();
instead of drawing every row.

Keep ROW_HEIGHT constant (update it only when the user changes font‑size, just like the old file did) and make every link compute its scroll position with index * ROW_HEIGHT. The IDs you already create (Gen_1_1) will keep working.

