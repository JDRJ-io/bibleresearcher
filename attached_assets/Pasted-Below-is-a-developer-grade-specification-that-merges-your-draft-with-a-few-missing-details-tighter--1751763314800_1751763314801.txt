Below is a developer‑grade specification that merges your draft with a few missing details, tighter wording, and uniform terminology.
Feel free to paste it directly into your repo’s README_DATA.md or into an onboarding wiki page.

0  Vocabulary & Conventions
Term	Meaning
verseID	Exact key string Book.Chapter:Verse (e.g. Gen.1:1). This never changes.
file code	Two‑ or three‑letter translation code (e.g. KJV, ESV).
resourceCache	In‑memory Map<string, unknown> that stores each fetched resource exactly once per session.
worker	Web Worker used for CPU‐heavy parse jobs.

1  Master Index (must load first)
Toggle	Files	Purpose
Canonical	metadata/verseKeys-canonical.json, metadata/dates-canonical.txt	Standard Bible order
Chronological	metadata/verseKeys-chronological.json, metadata/dates-chronological.txt	Historical timeline order

Fetch the chosen verseKeys-*.json → parse into const verseKeys: string[].

All later look‑ups are O(1) (verseKeys[index]).

The paired dates-*.txt is lazy‑loaded only if the Dates column is visible.

2  Core Verse Text Columns
Path translations/{CODE}.txt
Line format verseID #Verse text

On translation‑toggle “ON”

ts
Copy
if (!resourceCache.has(code)) {
  const blob = fetchOnce(`translations/${code}.txt`);
  const map  = parseTranslation(blob);   // returns Map<verseID, string>
  resourceCache.set(code, map);
}
activeTranslations.add(code);
renderViewport();           // ≈150 rows max
The first item in activeTranslations is rendered as the main column; it does not receive special CSS—its position alone conveys primacy.

3  Viewport Rendering (a.k.a. “anchor trick”)
ts
Copy
function loadChunk(centerRowIdx: number, buffer = 250) {
  const start = Math.max(0, centerRowIdx - buffer);
  const end   = Math.min(verseKeys.length, centerRowIdx + buffer);
  return verseKeys.slice(start, end);
}
Only the slice from start → end is materialized into DOM rows, keeping memory steady regardless of scroll depth.

4  Optional / Expandable Columns
Column	File(s)	Format & Parse Notes
Labels (“who / what / when / where”)	labels/{CODE}/ALL.json	JSON object { verseID: { who:[], what:[], … } }. Load on first toggle.
Context groups	metadata/context_groups.json	string[][] (array of contiguous verseID arrays). Use to light‑highlight narrative blocks or enable collapse section.
Dates	dates-*.txt (already chosen in §1)	Same delimiter as translations (#). verseID #Readable date.
Cross‑references	references/cf1.txt & cf2.txt	Line‑level grammar
mainID$$ref1#ref2#… → parallel passages
mainID$nextID → consecutive verses (single $). Parse with:
[before,$$?,after].
Prophecies (Prediction P / Fulfillment F / Verification V)	references/prophecy-file.txt	Example: Gen.25:18$12:V,27:F → Multiple IDs split on ,; each token ends with `:P
Strong’s (search & interlinear)	strongs/strongsIndex.json, strongs/strongsVerses.txt	Search panel uses strongsIndex.json (dictionary keyed by Strong’s #).
Interlinear popup fetches only the needed slice of strongsVerses.txt in a worker.

5  Performance & Threading Rules
Single fetch per file → via resourceCache.

Parse heavy or 5 MB+ files in workers (translation maps, Strong’s slices, prophecy dict).

Streaming parsers accepted: render rows as soon as first chunk of a translation arrives.

Strong’s 70 MB payloads stay cold until user triggers interlinear or lexical search.

6  UI → Data Event Cheat‑Sheet
markdown
Copy
User toggles translation ─┐
                          ├─ fetch translations/{CODE}.txt (if cache‑miss)
                          └─ renderViewport()

Scroll viewport          ─┤
                          └─ loadChunk(anchorIdx) → renderViewport()

User toggles Labels ─┤
                          └─ fetch labels/{translation code}/ALL.json → paint cells

User shows Prophecy col  ─┤
                          └─ fetch references/prophecy-file.txt → paint P|F|V cells

User clicks verse (Strong’s) ─┤
                               └─ worker fetch slice strongsVerses.txt → open interlinear pane
7  Key‑Join Guarantee
The exact same verseID string is the primary key across every dataset.

Switching canonical ⇆ chronological only reorders the master array—no other data change is required.

Therefore any join is a direct hash look‑up (map.get(verseID)) with no regex or fuzzy logic.