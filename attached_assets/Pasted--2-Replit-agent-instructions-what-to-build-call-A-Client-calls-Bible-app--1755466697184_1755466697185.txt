

---

# 2) Replit agent instructions (what to build / call)

## A) Client calls (Bible app)

**Bookmarks**

```ts
// toggle on
await supabase.from('user_bookmarks').upsert({
  translation, verse_key, // user_id is automatic via default
});

// toggle off
await supabase.from('user_bookmarks')
  .delete()
  .match({ translation, verse_key }); // RLS ensures it’s the caller’s row
```

**Highlights**

```ts
// segments = normalized [{start,end,color}]
const { error } = await supabase.rpc('save_highlights', {
  p_translation: translation,
  p_verse_key: verseKey,
  p_segments: segments,
  p_client_rev: serverRev ?? null,   // last known; optional
  p_text_len: verseText.length ?? null
});
```

**Load for a visible page (batch):**

```ts
const { data: bm } = await supabase
  .from('user_bookmarks')
  .select('translation, verse_key')
  .in('verse_key', visibleVerseKeys);

const { data: hl } = await supabase
  .from('user_highlights')
  .select('verse_key, segments, server_rev')
  .eq('translation', translation)
  .in('verse_key', visibleVerseKeys);
```

**Auth requirement:** before any of the above, ensure there’s a session:

```ts
const { data: { user } } = await supabase.auth.getUser();
if (!user) { /* prompt login */ }
```

## B) Admin Console (no changes needed for bookmarks/highlights)

* The console remains **read-only**, using your existing endpoints.
* Optional: add a tiny read-only panel later if you want to spot-check per-user counts:

  * counts of `user_bookmarks` / `user_highlights` (aggregates only; no PII).

## C) Quick tests for the agent (no mock data)

Ask the agent to run these **in the app** with a logged-in test user:

1. **Bookmarks round-trip**

   * Toggle bookmark ON for `KJV / John.3:16` → read it back → should exist.
   * Toggle OFF → read back → should be gone.

2. **Highlights round-trip**

   * Save `[ {start: 0, end: 12, color: 'yellow'} ]` for `KJV / John.3:16` via `rpc('save_highlights', …)`.
   * Read back row; confirm `server_rev` incremented and `segments` match (ordered).

3. **RLS isolation**

   * Sign out, sign in as a **different user**, fetch bookmarks/highlights → should see **none** of the first user’s rows.

4. **Offset clamping (optional)**

   * Send a segment with `end > verseText.length` while passing `p_text_len`.
   * Read back: segment should be clamped to the verse length.

If any step fails, have the agent paste the exact Supabase error JSON from the Network tab so we can pinpoint RLS vs. payload issues.

---

## FAQ you might get from the agent

* **“Do we still need to pass `user_id`?”**
  No. Defaults + RLS handle it. Only pass `user_id` in server/admin scripts (never in the browser).

* **“Will users see each other’s data?”**
  No. RLS policies restrict rows to `auth.uid() = user_id`.

* **“Can we mass import existing bookmarks/highlights?”**
  Yes — do it from your **Admin Console** using a service role (server-side), writing actual `user_id` values. RLS won’t apply to service role.

---

If you run the SQL bundle in both Supabase projects and give the agent the client call snippets + tests above, you’ll have clean, user-scoped bookmarks and highlights working — with zero mock data and strong isolation.


// highlights.ts

export type Segment = { start: number; end: number; color: string };
// Convention: [start,end) ranges (start inclusive, end exclusive)

function normalize(segments: Segment[]): Segment[] {
  if (!segments.length) return [];
  segments.sort((a, b) => a.start - b.start);
  const result: Segment[] = [];
  let prev = { ...segments[0] };

  for (let i = 1; i < segments.length; i++) {
    const cur = segments[i];
    if (cur.start <= prev.end && cur.color === prev.color) {
      // merge overlapping/adjacent same-color
      prev.end = Math.max(prev.end, cur.end);
    } else {
      result.push(prev);
      prev = { ...cur };
    }
  }
  result.push(prev);
  return result;
}

export function addRange(
  segments: Segment[],
  start: number,
  end: number,
  color: string
): Segment[] {
  if (start >= end) return segments;
  const result: Segment[] = [];
  let inserted = false;

  for (const seg of segments) {
    // before new
    if (seg.end <= start || seg.start >= end) {
      result.push(seg);
      continue;
    }
    // overlap: keep non-overlapping parts
    if (seg.start < start) result.push({ start: seg.start, end: start, color: seg.color });
    if (seg.end > end) result.push({ start: end, end: seg.end, color: seg.color });
  }
  // insert new segment
  result.push({ start, end, color });
  return normalize(result);
}

export function removeRange(
  segments: Segment[],
  start: number,
  end: number
): Segment[] {
  if (start >= end) return segments;
  const result: Segment[] = [];

  for (const seg of segments) {
    if (seg.end <= start || seg.start >= end) {
      // untouched
      result.push(seg);
      continue;
    }
    // overlap
    if (seg.start < start) result.push({ start: seg.start, end: start, color: seg.color });
    if (seg.end > end) result.push({ start: end, end: seg.end, color: seg.color });
  }
  return normalize(result);
}

export function recolorRange(
  segments: Segment[],
  start: number,
  end: number,
  newColor: string
): Segment[] {
  return addRange(removeRange(segments, start, end), start, end, newColor);
}

