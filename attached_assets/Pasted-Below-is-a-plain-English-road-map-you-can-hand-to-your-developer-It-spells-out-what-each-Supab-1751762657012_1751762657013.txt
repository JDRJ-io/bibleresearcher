Below is a plain-English “road-map” you can hand to your developer.  It spells out **what each Supabase file is for, when it should be fetched, and how the app tells one data-type from another while building the verse table**.

---

### 1.  Pick an ordering first → loads the master index

* **Canonical vs. Chronological toggle**

  * Canonical → `metadata/verseKeys-canonical.json` & `dates-canonical.txt`
  * Chronological → `metadata/verseKeys-chronological.json` & `dates-chronological.txt`
* The chosen `verseKeys-*.json` is parsed into an **array of verse IDs** (e.g. `"Gen.1:1"`).
  That array is the single source-of-truth for the table’s row order.  Every other dataset uses exactly those same IDs, so look-ups stay trivial.&#x20;

---

### 2.  Core verse text columns

* Each translation lives in `translations/{CODE}.txt` (one line per verse: `ID #Verse text`).
* When the user turns a translation **on**:

  1. Fetch the file once (private Supabase fetch, then cache in `resourceCache`).
  2. Build a `Map<verseID, string>` for that language.
  3. Re-render visible rows; main translation is just the first entry in your `activeTranslations` array—no special styling needed.&#x20;

---

### 3.  Lazy row rendering & the anchor trick

* Virtual table shows only the viewport slice + buffer.
* A scroll watcher keeps track of the **center row index**; `loadChunk(center)` pulls the next batch above & below that anchor—not from the ends—so memory stays flat.
* Every row render simply:

  ```ts
  const id   = verseKeys[index];
  const text = translationMaps[code].get(id);
  ```

  and repeats for each active column.

---

### 4.  Optional / expandable columns

| Column                             | File(s)                                                                                          | How to parse & show                                                                                                                                                                                                         |
| ---------------------------------- | ------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Labels** (“who / what / when …”) | `labels/{CODE}/ALL.json`                                                                         | JSON: `{ verseID: {who:[], what:[], …} }`.  Load on first time the label column is revealed, keep in cache.                                                                                                                 |
| **Context groups** (verse chains)  | `metadata/context_groups.json`                                                                   | An array-of-arrays.  Use to highlight / collapse contiguous narrative blocks.                                                                                                                                               |
| **Dates**                          | `dates-*.txt` chosen in step 1                                                                   | Split line on `" #"` → show date string.                                                                                                                                                                                    |
| **Cross-references**               | `references/cf1.txt`, `references/cf2.txt`                                                       | Line format: `main$$refs1#refs2#…`.  Split on double`$$` then `#`; show as nested reference lists. but if single "$" it shows 2 verses are consecutive                                                                                                                           |
| **Prophecy (P / F / V)**           | `references/prophecy-file.txt`                                                                   | Each entry is `verseID $ prophecyID:P,F,V`.  Pre-index into `{ verseID: {P:[],F:[],V:[]} }` so you can paint three separate columns.       can be multiple prophecies associated to a single row differentiated like so Gen.25:18$12:V,27:F with ","
                                                                                |
| **Strong’s word study**            | `strongs/strongsIndex.json` (for search) & `strongs/strongsVerses.txt` (for per-verse breakdown) | \* When user clicks a verse: fetch only the needed slice of `strongsVerses.txt` in a Web Worker and render the interlinear popup. \* Clicking a word opens a panel that uses `strongsIndex.json` to list every occurrence.  |

---

### 5.  Performance & threading rules

1. **One fetch per resource per session** → `resourceCache`.
2. **Big parsers live in Web Workers** so the main thread only receives ready-to-render objects.
3. **Streaming fetch** is fine—the table can start painting rows as soon as the first chunk of the translation arrives.
4. **70 MB Strong’s files**: never load on startup; gate them behind the first user interaction that needs them.

---

### 6.  Event flow cheat-sheet

```
User toggles translation  ─┐
                          fetch translations/XX.txt
                          cache Map<id,text>
                          rerender visible rows
                          
Scroll → new anchor index ─┤
                          loadChunk(anchor)  (uses verseKeys[])
                          update rows

User shows labels column  ─┤
                          fetch labels/XX/ALL.json (per active translation)
                          cache and paint label cells

User clicks prophecy cell ─┤
                          lookup verseID in prophecyDict
                          open detail panel

User expands verse (Strong’s) ─┤
                          worker fetch slice from strongsVerses.txt
                          show interlinear
```

---

### 7.  Why everything “just joins”

* Every dataset keys on **exactly** the same `Book.Chapter:Verse` string—no regex gymnastics.
* Whether you view canonical or chronological, the **keys never change**, only their order in the master array, so cross-dataset joins are O(1).

Hand this outline to your developer and they’ll know **which file loads when, what each delimiter means, and how the UI decides which worker or parser to invoke.**
