I hear you. Let’s **fix alignment + stop the left indent** without touching your working layout. Do these 6 micro-patches only:

---

## 1) Kill the hidden left-indent that turns on with alt/prophecy

(Add this anywhere after your main table CSS.)

```css
/* HOTFIX: when alt/prophecy flags are on, do NOT pad/shift the body */
[class*="has-alt"] .virtual-rows,
[class*="has-alt"] .virtual-row,
[class*="has-proph"] .virtual-rows,
[class*="has-proph"] .virtual-row,
.virtual-table.has-alt,
.virtual-table.has-proph {
  padding-left: 0 !important;
  margin-left: 0 !important;
  transform: none !important; /* cancels legacy translateX pillar hack */
}
```

> This neutralizes the legacy “pillar padding” rule that’s re-applied only when alt or prophecy columns are active.

---

## 2) Make header + rows render with the **same grid template** (no drift)

(Keep your structure. Just compute the template once in each file using the *same* keys & gap.)

```tsx
// In NewColumnHeaders.tsx
const { start, end } = useBibleStore(s => s.getVisibleSlice());
const fixedKeys = useBibleStore(s => s.fixedColumns);
const navKeys   = useBibleStore(s => s.navigableColumns);
const widths    = useBibleStore(s => s.columnWidthsPx);
const gapPx     = useBibleStore(s => s.gapPx);

const headerTemplate = useMemo(() => {
  const keys = [...fixedKeys, ...navKeys.slice(start, end)];
  return keys.map(k => `${(widths?.[k] ?? 280)}px`).join(' ');
}, [fixedKeys, navKeys, start, end, widths]);

// Apply to the header grid wrapper
<div className="grid sticky-header"
     style={{ gridTemplateColumns: headerTemplate, columnGap: gapPx }}>
```

```tsx
// In VirtualRow.tsx (use the same exact logic)
const { start, end } = useBibleStore(s => s.getVisibleSlice());
const fixedKeys = useBibleStore(s => s.fixedColumns);
const navKeys   = useBibleStore(s => s.navigableColumns);
const widths    = useBibleStore(s => s.columnWidthsPx);
const gapPx     = useBibleStore(s => s.gapPx);

const rowTemplate = useMemo(() => {
  const keys = [...fixedKeys, ...navKeys.slice(start, end)];
  return keys.map(k => `${(widths?.[k] ?? 280)}px`).join(' ');
}, [fixedKeys, navKeys, start, end, widths]);

<div className="grid row-grid"
     style={{ gridTemplateColumns: rowTemplate, columnGap: gapPx }}>
```

> Using the identical key list + gap on both sides stops the header/body de-sync.

---

## 3) Keep the header sticky; keep the body vertical-only

(If you already have this, leave it. Otherwise add it.)

```css
.table-viewport { overflow-y: auto; overflow-x: hidden; scrollbar-gutter: stable both-edges; }
.sticky-header  { position: sticky; top: 0; z-index: 30; background: var(--bg-surface); }
.grid           { min-width: 0; }  /* prevents “grid grows wider than container” */
```

> `scrollbar-gutter: stable` prevents the vertical scrollbar from nudging body width and misaligning the header.

---

## 4) Make fixed columns sticky (not padded)

(Reference column—and index if you have one.)

```css
.header-cell.reference, .data-cell.reference { position: sticky; left: 0; z-index: 2; background: var(--bg-surface); }

/* If you also have a #/index column: place it at left:0 and bump reference by that width */
.header-cell.index, .data-cell.index { position: sticky; left: 0; z-index: 3; }
.header-cell.reference, .data-cell.reference { left: var(--index-col-width, 140px); }
```

> This keeps fixed tracks visible **without** pushing the whole table right.

---

## 5) Make arrows step **exactly one** navigable column (ref not counted)

(Replace only these functions in your store—names as you already use them.)

```ts
navigateColumnLeft: () =>
  set(s => ({ columnOffset: Math.max(0, s.columnOffset - 1) })),

navigateColumnRight: () =>
  set(s => {
    const tracks = Math.max(1, (s.visibleCount ?? s.visibleNavigableCount) - (s.fixedColumns?.length ?? 0)); // your 3–20
    const maxOffset = Math.max(0, (s.navigableColumns?.length ?? 0) - tracks);
    return { columnOffset: Math.min(s.columnOffset + 1, maxOffset) };
  }),

getVisibleSlice: () => {
  const s = get();
  const tracks = Math.max(1, (s.visibleCount ?? s.visibleNavigableCount) - (s.fixedColumns?.length ?? 0));
  const total  = s.navigableColumns?.length ?? 0;
  const maxOff = Math.max(0, total - tracks);
  const start  = Math.min(s.columnOffset ?? 0, maxOff);
  const end    = Math.min(total, start + tracks);
  return { start, end, canGoLeft: start > 0, canGoRight: end < total };
}
```

> This restores horizontal nav even when only main + a few cols are present, and it’s independent of prophecy/alt toggles.

---

## 6) Remove the last lurking “pillar” pad if it exists in JS

Search and delete (or force to 0) anywhere in your table body wrapper:

```tsx
// DELETE or set to 0 if you find any of these:
style={{ paddingLeft: pillarWidthPx }}
style={{ marginLeft: pillarWidthPx }}
style={{ transform: `translateX(${pillarWidthPx}px)` }}
className="padForPillar rowsPadForPillar hasPillar"
```

---

### What will change (and only this):

* Alt/prophecy no longer inject a left gutter.
* Header stays perfectly aligned with rows (same template + gap).
* Horizontal arrows always work (step = 1 col), regardless of which optional columns are loaded.
* No row stacking, no layout rewrite.

If anything *still* shifts after these, the culprit is a single leftover CSS rule tied to a state class (often `.has-alt`, `.has-proph`, or `.has-pillar`). Delete that rule and you’re done.
