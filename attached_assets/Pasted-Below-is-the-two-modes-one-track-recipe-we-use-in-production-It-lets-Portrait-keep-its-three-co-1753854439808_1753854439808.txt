Below is the “two-modes / one-track” recipe we use in production.
It lets Portrait keep its three-column autofit while Landscape keeps its centre-until-overflow behaviour—both driven only by orientation media-queries, so they live happily in the same markup.

⸻

1 Add orientation break-points once, reuse everywhere

<details>
<summary>tailwind.config.js snippet</summary>


module.exports = {
  theme: {
    extend: {
      screens: {
        /* True device orientation, not width buckets */
        portrait:  { raw: '(orientation: portrait)'  },
        landscape: { raw: '(orientation: landscape)' },
      },
    },
  },
};

</details>


Now every class can be prefixed with portrait: or landscape:.

⸻

2 Wrapper + track: identical for both modes

/* BibleTableShell.tsx */
export function BibleTableShell({ children }: { children: React.ReactNode }) {
  /* single ref is shared by verse-jump & anchor logic */
  const scrollRef = useRef<HTMLDivElement>(null);
  useCenterIfFits(scrollRef);      // ← from previous answer

  return (
    /* Horizontal scroller                 */
    <div
      ref={scrollRef}
      className="
        w-full h-full
        overflow-x-auto overflow-y-hidden
        overscroll-x-contain touch-pan-x   /* smooth swipe */
      "
    >
      {/* Flex track that grows to its content width       */}
      <div
        className="
          flex flex-row items-stretch
          w-max mx-auto           /* centre while it fits */
          portrait:h-full         /* avoid extra height in ~iOS  */
        "
      >
        {children}
      </div>
    </div>
  );
}

Nothing in here is orientation-specific except the portrait:h-full quirk for iOS.
All orientation rules live on the individual columns.

⸻

3 Columns that morph width by orientation

/* ColumnWidths.ts */
export const W = {
  ref: 'w-[72px] shrink-0',

  /** Main + Cross-Ref split the leftover width only in PORTRAIT */
  main:  'portrait:w-[calc((100dvw-72px)/2)]  landscape:w-[320px] shrink-0',
  xref:  'portrait:w-[calc((100dvw-72px)/2)]  landscape:w-[320px] shrink-0',

  /* any other extra columns – keep fixed px everywhere */
  label: 'w-[260px] shrink-0',
};

	•	100dvw is the “dynamic viewport” unit—solves iOS safe-area issues.
	•	Landscape always uses fixed pixel widths → track width is predictable.
	•	Portrait rule guarantees exact fit of the first three columns (72 + 2×calc) — no horizontal scroll until you add a 4th column.

⸻

4 Putting columns in the track

export function VirtualBibleTable() {
  return (
    <BibleTableShell>
      <RefCol   className={W.ref}  />
      <MainCol  className={W.main} />
      <XRefCol  className={W.xref} />
      {extraCols.map(c => (
        <ExtraCol key={c.id} className={W.label} />
      ))}
    </BibleTableShell>
  );
}

Same markup serves both modes; only the classes decide the layout.

⸻

5 Handling live orientation flips
	1.	CSS side – as soon as the media-query flips, column widths update and the track may grow or shrink.
	2.	JS side – your virtualiser (react-virtual, tanstack/virtual, etc.) needs a tiny nudge:

const rowVirtualizer = useVirtual({ /* … */ });

useEffect(() => {
  const onResize = () => rowVirtualizer.measure();   // recalc row heights
  window.addEventListener('resize', onResize, { passive: true });
  return () => window.removeEventListener('resize', onResize);
}, []);

Because we never transform the track, scrollLeft stays valid—no extra code needed.

⸻

6 Sanity-check matrix

Scenario	Result
Phone portrait, 3 cols	No horizontal scroll bar. Each col fills exactly its slot.
Phone portrait, +1 extra col	Track wider → overflow-x:auto kicks in; user swipes.
Tablet landscape, 2–3 cols	Track width ≤ viewport → centred via mx-auto.
Tablet/desktop landscape, 4+ cols	Track wider → margins collapse to 0, track hugs left edge, scrollbar appears with start = 0.
User scrolls, then rotates	useCenterIfFits sees userScrolled=true; it never snaps on rotate, respecting scroll position.



⸻

Common pitfalls avoided
	•	“Bounce-back” – solved by guarding with userScrolled.
	•	Different container refs – only one scrollRef, passed everywhere.
	•	Portrait calc rounding – use 100dvw not 100vw to survive iOS address-bar jumps.

Drop these snippets in and both orientations will respect their own rules without ever conflicting.