Let’s wire the Cross-Reference and Prophecy columns end-to-end

You already have the bucket paths and the new BibleDataAPI helpers.
Below is the exact implementation flow for both column types.

⸻

1  Verify the raw data assets exist in Supabase

Asset	Expected bucket path	Check-list
Cross-ref slices	references/cf1.txt, references/cf2.txt	UTF-8 text, one record per line.
Cross-ref offsets	references/cf1_offsets.json, references/cf2_offsets.json	{ "Gen.1:1": [start,end], … }
Prophecy rows	references/prophecy_rows.txt	TSV or JSON lines (Prediction
Prophecy index	references/prophecy_index.json	{ "Gen.22:8": [rowStart,rowEnd], … }

If any of these are missing or you see “expired” messages in Replit, re-upload them now before coding.

⸻

2  Add fetch helpers to BibleDataAPI.ts

(If you already added offsets in the previous step, just paste the prophecy helper.)

// -------- Prophecy loaders ----------
let prophecyIndex: Record<string, [number, number]> | null = null;
let prophecyRowsTxt: string | null = null;

export async function getProphecy(indexKey: string) {
  // Lazy load index JSON
  if (!prophecyIndex) {
    const idx = await fetchFromStorage('references/prophecy_index.json');
    prophecyIndex = JSON.parse(idx);
  }
  // Lazy load rows file
  if (!prophecyRowsTxt) {
    prophecyRowsTxt = await fetchFromStorage('references/prophecy_rows.txt');
  }
  const slice = prophecyIndex![indexKey];
  if (!slice) return null;
  return prophecyRowsTxt!.substring(slice[0], slice[1]);
}



⸻

3  Cross-Reference Worker logic

3-A Main thread (inside useCrossRefLoader.ts)

const offsets = await BibleDataAPI.getCfOffsets(cfSet);          // cf1 or cf2
const [start, end] = offsets[verseKey] ?? [];
if (start !== undefined) {
  const slice = await BibleDataAPI.getCrossRefSlice(cfSet, start, end);
  crossWorker.postMessage({ type: 'cfData', key: verseKey, text: slice });
}

3-B Worker side

self.onmessage = (e) => {
  if (e.data.type === 'cfData') {
    const { key, text } = e.data;
    const refs = text.split('|');              // or JSON.parse
    // cache in worker memory for reuse
    refCache.set(key, refs);
    self.postMessage({ key, refs });
  }
};



⸻

4  ProphecyColumns.tsx logic

const { main } = useTranslationMaps();
const [pred, setPred] = useState<string | null>(null);
const [ful, setFul] = useState<string | null>(null);
const [ver, setVer] = useState<string | null>(null);

useEffect(() => {
  BibleDataAPI.getProphecy(verseKey).then((row) => {
    if (!row) return;
    const [pKey, fKey, vKey] = row.split('\t'); // adjust parser
    setPred(pKey);
    setFul(fKey);
    setVer(vKey);
  });
}, [verseKey]);

return (
  <>
    <Cell translationId={main} verseKey={pred}  />
    <Cell translationId={main} verseKey={ful}  />
    <Cell translationId={main} verseKey={ver}  />
  </>
);

Your existing Cell component already knows how to display main translation text for a verseKey; it will lazily fetch via BibleDataAPI master cache.

⸻

5  Loading skeletons

While offsets or prophecy rows are still fetching, show the same skeleton shimmer used for verse columns:

if (!pred) return <SkeletonCell />;



⸻

6  Cypress smoke tests

// cypress/e2e/prophesy.cy.js
it('shows prophecy rows', () => {
  cy.visit('/bible?ref=Gen.22');
  cy.findByText('Prediction').should('be.visible');  // header
  cy.findByText('Gen.22:8').should('exist');         // pred ref
});

// cypress/e2e/crossref.cy.js
it('shows cross refs', () => {
  cy.visit('/bible?ref=John.3');
  cy.findAllByText(/Num\./).first().should('be.visible');
});



⸻

7  Network verification
	•	DevTools → filter by references/ → scroll the Bible.
	•	You should see:
	•	cf1_offsets.json, cf1.txt (once)
	•	prophecy_rows.txt, prophecy_index.json (once)
	•	No cf1.txt re-downloads, no /api/references calls.

⸻

8  Edge-case handling

Situation	Handler
Verse has no prophecy entry	getProphecy returns null; ProphecyColumns renders empty cells.
Offsets missing key	Worker posts { key, refs: [] }; Column shows “—”.
User toggles prophecy columns off	Don’t fetch prophecy files until first time columns are visible.


.