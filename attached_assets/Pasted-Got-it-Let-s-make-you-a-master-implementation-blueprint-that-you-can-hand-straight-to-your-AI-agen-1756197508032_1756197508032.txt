Got it ✅ Let’s make you a master implementation blueprint that you can hand straight to your AI agent. This is not just code, but also the rules, architecture, and edge-case handling so the agent won’t get lost or fall into the “sticky diagonal” trap again.

⸻

🧭 Axis-Locked Scrolling – Master Implementation Guide

🎯 Goal
	•	Virtual table scrolls only on one axis at a time (X or Y).
	•	Axis is chosen per gesture (wheel burst, touch drag).
	•	Axis can switch smoothly mid-gesture if dominance changes.
	•	Axis resets automatically after gesture ends.
	•	Works across touch, wheel/trackpad, keyboard.
	•	Never requires a “tap reset.”

⸻

📐 Core Principles
	1.	Start Free – Every gesture begins without an axis lock.
	2.	Quick Lock – As soon as one axis dominates (|dx| > |dy| × ratio), lock to that axis.
	3.	Continuous Re-eval – If the other axis takes dominance, flip lock immediately (no pause).
	4.	Auto-Reset – When gesture ends (touchend / wheel idle timeout), axis resets to null.
	5.	One Source of Truth – Axis lock is tracked in one place (axisRef). All inputs consult it.

⸻

🔧 Implementation Steps

1. CSS (baseline support)

.virtualTableViewport {
  overflow: auto;
  overscroll-behavior: contain;        /* keep scroll local */
  touch-action: pan-x pan-y pinch-zoom;/* allow both, JS decides */
  -webkit-overflow-scrolling: touch;   /* smooth inertia */
}


⸻

2. React Hook (unified input lock)

import { useEffect, useRef } from "react";

type Axis = "x" | "y" | null;

interface Options {
  dominanceRatio?: number; // how much stronger one axis must be to win
  wheelUnlockMs?: number;  // reset delay for wheel bursts
}

export function useSmoothAxisLock<T extends HTMLElement>(
  ref: React.RefObject<T>,
  { dominanceRatio = 1.2, wheelUnlockMs = 160 }: Options = {}
) {
  const axisRef = useRef<Axis>(null);

  // ============ TOUCH ============
  const touchLast = useRef<{ x: number; y: number } | null>(null);
  useEffect(() => {
    const el = ref.current;
    if (!el) return;

    const onStart = (e: TouchEvent) => {
      const t = e.touches[0];
      touchLast.current = { x: t.clientX, y: t.clientY };
      axisRef.current = null; // reset per gesture
    };

    const onMove = (e: TouchEvent) => {
      const t = e.touches[0];
      if (!touchLast.current) return;

      const dx = t.clientX - touchLast.current.x;
      const dy = t.clientY - touchLast.current.y;

      // Pick or flip axis based on dominance
      if (
        !axisRef.current ||
        Math.abs(dx) > Math.abs(dy) * dominanceRatio ||
        Math.abs(dy) > Math.abs(dx) * dominanceRatio
      ) {
        axisRef.current = Math.abs(dx) > Math.abs(dy) ? "x" : "y";
      }

      e.preventDefault(); // kill diagonal scroll
      if (axisRef.current === "x") el.scrollLeft -= dx;
      else el.scrollTop -= dy;

      touchLast.current = { x: t.clientX, y: t.clientY };
    };

    const onEnd = () => {
      axisRef.current = null;
      touchLast.current = null;
    };

    el.addEventListener("touchstart", onStart, { passive: true });
    el.addEventListener("touchmove", onMove, { passive: false });
    el.addEventListener("touchend", onEnd, { passive: true });

    return () => {
      el.removeEventListener("touchstart", onStart as any);
      el.removeEventListener("touchmove", onMove as any);
      el.removeEventListener("touchend", onEnd as any);
    };
  }, [ref, dominanceRatio]);

  // ============ WHEEL ============
  useEffect(() => {
    const el = ref.current;
    if (!el) return;

    let accX = 0,
      accY = 0,
      timer: number | null = null;

    const reset = () => {
      axisRef.current = null;
      accX = accY = 0;
      if (timer) clearTimeout(timer);
      timer = null;
    };

    const scheduleReset = () => {
      if (timer) clearTimeout(timer);
      timer = window.setTimeout(reset, wheelUnlockMs);
    };

    const onWheel = (e: WheelEvent) => {
      if (!axisRef.current) {
        accX += Math.abs(e.deltaX);
        accY += Math.abs(e.deltaY);

        if (
          accX > accY * dominanceRatio ||
          accY > accX * dominanceRatio
        ) {
          axisRef.current = accX >= accY ? "x" : "y";
        } else {
          // Still undecided → let browser handle diagonal until clear
          scheduleReset();
          return;
        }
      }

      e.preventDefault();
      if (axisRef.current === "x") {
        const delta = e.deltaX !== 0 ? e.deltaX : e.deltaY;
        el.scrollLeft += delta;
      } else {
        const delta = e.deltaY !== 0 ? e.deltaY : e.deltaX;
        el.scrollTop += delta;
      }

      scheduleReset();
    };

    el.addEventListener("wheel", onWheel, { passive: false });
    return () => {
      el.removeEventListener("wheel", onWheel as any);
      if (timer) clearTimeout(timer);
    };
  }, [ref, dominanceRatio, wheelUnlockMs]);

  // ============ KEYBOARD ============
  useEffect(() => {
    const el = ref.current;
    if (!el) return;

    const onKey = (e: KeyboardEvent) => {
      if (!el.contains(document.activeElement)) return;

      switch (e.key) {
        case "ArrowRight": el.scrollLeft += 40; e.preventDefault(); break;
        case "ArrowLeft":  el.scrollLeft -= 40; e.preventDefault(); break;
        case "ArrowDown":  el.scrollTop += 40; e.preventDefault(); break;
        case "ArrowUp":    el.scrollTop -= 40; e.preventDefault(); break;
        case "PageDown":   el.scrollTop += el.clientHeight * 0.8; e.preventDefault(); break;
        case "PageUp":     el.scrollTop -= el.clientHeight * 0.8; e.preventDefault(); break;
        case "Home":       el.scrollTop = 0; e.preventDefault(); break;
        case "End":        el.scrollTop = el.scrollHeight; e.preventDefault(); break;
      }
    };

    window.addEventListener("keydown", onKey, { passive: false });
    return () => window.removeEventListener("keydown", onKey as any);
  }, [ref]);
}


⸻

3. Usage in your table

const viewportRef = useRef<HTMLDivElement>(null);
useSmoothAxisLock(viewportRef);

return (
  <div ref={viewportRef} className="virtualTableViewport">
    {/* your virtualized table */}
  </div>
);


⸻

🧪 Test Checklist (for the agent)
	1.	Touch swipe horizontal: moves only X.
	2.	Touch swipe vertical: moves only Y.
	3.	Touch diagonal swipe: locks to stronger axis, flips if drift changes dominance.
	4.	Wheel horizontal swipe: locks to X, no diagonal.
	5.	Wheel vertical swipe: locks to Y, no diagonal.
	6.	Wheel diagonal swipe: free until dominance emerges, then locks.
	7.	Pause after wheel burst: axis resets; next gesture starts fresh.
	8.	Keyboard arrows/PageUp/Down/Home/End: scrolls in expected single axis.
	9.	Mobile Safari: no rubber-band or diagonal bleed.
	10.	Desktop Chrome/Firefox/Edge: smooth and responsive.

⸻

🚨 Rules to Drill into the Agent
	•	Never pre-lock before movement starts.
	•	Lock fast, but flip fast if dominance changes.
	•	Always reset axis lock at end of gesture (touchend / wheel idle).
	•	Keep CSS support: touch-action: pan-x pan-y, overscroll-behavior: contain.
	•	Test all input types: touch, wheel, keyboard.

⸻

👉 That’s your master blueprint.
If you give this whole guideline + code + test checklist to your AI agent, they’ll know exactly what to implement and why.

Do you want me to also draw a flow diagram (like: Gesture Start → Measure deltas → Decide Axis → Apply Scroll → Re-evaluate → Reset) that you can show your agent visually?