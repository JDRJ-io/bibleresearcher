Here’s a surgical plan to get your cross-reference jumps working again without touching the axis-locking work you just added.

⸻

1 — Why it broke (diagram)

BiblePage
 ├─ tableRef ──► makeScrollToVerse()  ←── useVerseNav() ←── click handler
 │
 └─ <VirtualBibleTable ref={tableRef}/>   (❌ BUT…)
            └─ internal containerRef (the real scrollable <div>)

tableRef.current never points to the scrollable element, so scrollToVerse() ends up calling scrollTop on undefined.

⸻

2 — The quickest, safest fix: forward the real ref

// VirtualBibleTable.tsx
import React, { forwardRef, useRef, useImperativeHandle } from 'react';

export interface VBibleTableHandle {
  scrollToVerse: (ref: string) => void;
}

const VirtualBibleTable = forwardRef<VBibleTableHandle, Props>((props, ref) => {
  const containerRef = useRef<HTMLDivElement>(null);

  /* Internal scroll helper stays as is */
  function scrollToVerse(localRef: string) {
    // ... your binary-search / virtual-row logic ...
    containerRef.current?.scrollTo({ top, behavior: 'smooth' });
  }

  /** expose BOTH the node and the function */
  useImperativeHandle(ref, () => ({
    scrollToVerse,
    /* optional: expose the element itself */
    get node() {
      return containerRef.current!;
    },
  }));

  return (
    <div ref={containerRef} className="v-scroll">
      {/* rows */}
    </div>
  );
});
export default VirtualBibleTable;

What changed
	•	forwardRef now gives BiblePage a handle object with scrollToVerse.
	•	No leaking of internals; the outer world can only call what you expose.

⸻

3 — Call the right scroll function everywhere

// BiblePage.tsx
const tableRef = useRef<VBibleTableHandle>(null);

const scrollToVerse = (ref: string) => {
  tableRef.current?.scrollToVerse(ref);   // ← always valid
};

useVerseNav(scrollToVerse);               // navigation hook

The click chain you listed (handleCrossRefClick → onVerseClick → goTo → scrollToVerse)
now resolves to one single implementation—no ambiguity, no mismatched container.

⸻

4 — Double-check with one console line

console.log('table node is', tableRef.current?.node); // should log the v-scroll div

If you see null you still have a ref timing issue; wrap the log in useEffect(() => {}, [tableRef.current]).

⸻

5 — Edge-case checklist

Item	Why it matters
Only one scroll helper exported	Prevents “two versions” diverging again
overscroll-behavior: contain kept on the container	Your axis-locking stays flawless
Virtual rows overscan ≥ 2 screens	Guarantees target verse is mounted before scroll fires
behavior: 'smooth' vs instant	Keep the buttery feel; change to 'auto' if you profile jank



⸻

TL;DR
	•	Forward containerRef + scrollToVerse via useImperativeHandle.
	•	Have every navigation path call that one function.
	•	Hyperlinks will jump precisely again, and your shiny new scroll physics stay untouched.