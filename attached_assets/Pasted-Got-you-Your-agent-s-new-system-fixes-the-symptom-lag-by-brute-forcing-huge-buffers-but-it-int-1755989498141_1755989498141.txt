Got you. Your agent’s “new system” fixes the symptom (lag) by brute-forcing huge buffers, but it introduces serious side effects: runaway data use, memory churn, stale/duplicated requests, and work on non-visible columns (cross-refs/prophecy) that starve the main translation. Below is a drop-in plan + patches to make the loader truly predictive and efficient.

# What’s wrong with the NEW approach (quick audit)

* **Massive buffers (200–500)** per tick × multi-columns ⇒ **hundreds of KB–MB per tick**, easily ballooning into GBs over a session.
* **Update every 5 verses** creates an **event storm** during fast scrolls/drag—tons of overlapping fetches.
* Preloading “thousands for cross-refs/prophecy” before main text guarantees “no gaps” but **starves the critical path** and kills mobile memory.
* Logging “continuous loading” ≠ correctness—there’s no guardrails against **big jumps** (scrollbar drags, programmatic jumps).

# Replace with an Adaptive Predictive Virtualizer (APV)

## Core rules

1. **Prioritize main translation** for the **visible window** + a **modest lead/lag** that **scales with velocity**.
2. **Cross-refs/prophecy**: only the **visible window**, then **thin prefetch** (not massive), and **only after** main text resolves.
3. **Throttle updates** by time & verse delta; **coalesce** and **cancel** in-flight work when the user changes direction or jumps.
4. **Handle big jumps & drags** with a fast path (abort, skeleton render, fetch main, then extras).
5. **Put hard caps** on verses/min & concurrency to prevent data explosions.

---

## Tunables (safe defaults)

```ts
// Windowing (verses)
const VISIBLE      = 40;   // verses roughly on screen (depends on row height)
const LEAD_BASE    = 60;   // ahead of anchor at low speed
const LAG_BASE     = 30;   // behind anchor at low speed
const LEAD_MAX     = 200;  // max ahead at high speed
const LAG_MAX      = 80;   // max behind at high speed

// Velocity (verses/second) breakpoints
const V1 = 5;   // slow scroll
const V2 = 20;  // fast scroll
const V3 = 80;  // fling/jump-ish

// Update cadence
const MIN_UPDATE_MS   = 80;   // rAF-ish throttling
const MAX_UPDATE_MS   = 220;  // ensure periodic refresh
const MIN_VERSE_DELTA = 10;   // don’t recompute unless anchor moves this much

// Jump/drag handling
const BIG_JUMP_VERSES = 400;    // treat as jump if delta exceeds this
const DRAG_PAUSE_MS   = 50;     // pause while dragging scrollbar, resume after

// Networking / concurrency
const MAX_CONCURRENCY        = 4;   // per translation stream
const MAX_VERSES_PER_MIN     = 4000; // global budget (all columns); tune to avoid GB use
const PREFETCH_XREF_MARGIN   = 10;  // small halo for xrefs/prophecy beyond visible
const CACHE_SOFT_LIMIT_ROWS  = 1200; // LRU soft cap (per translation)
```

---

## Adaptive window based on velocity

```ts
function computeLeadLag(vps: number, direction: 1 | -1) {
  // scale ahead more than behind, but keep some tail for reverse scrolls
  const t = Math.min(1, Math.max(0, (vps - V1) / (V3 - V1))); // 0..1
  const lead = Math.round(LEAD_BASE + t * (LEAD_MAX - LEAD_BASE));
  const lag  = Math.round(LAG_BASE  + t * (LAG_MAX  - LAG_BASE));
  return direction === 1 ? { lead, lag } : { lead: lag, lag: lead }; // bias toward direction
}

function computeWindow(anchor: number, vps: number, dir: 1|-1) {
  const { lead, lag } = computeLeadLag(vps, dir);
  const start = Math.max(1, anchor - (VISIBLE/2 + lag));
  const end   = anchor + (VISIBLE/2 + lead);
  return { start, end };
}
```

---

## Throttled, cancellable scheduler

```ts
type Range = { start: number; end: number };

const inflight = new Map<string, AbortController>(); // key: `${col}:${start}-${end}`
let lastUpdateTs = 0;
let lastAnchor = 1;
let versesThisMinute = 0;

function shouldUpdate(now: number, anchor: number) {
  const timeOk  = (now - lastUpdateTs) >= MIN_UPDATE_MS || (now - lastUpdateTs) >= MAX_UPDATE_MS;
  const deltaOk = Math.abs(anchor - lastAnchor) >= MIN_VERSE_DELTA;
  return timeOk && deltaOk;
}

function cancelInflightOutside(range: Range) {
  for (const [key, ctl] of inflight) {
    const [, s, e] = key.match(/:(\d+)-(\d+)$/) || [];
    if (!s || !e) continue;
    const ks = +s, ke = +e;
    const overlap = !(ke < range.start || ks > range.end);
    if (!overlap) { ctl.abort(); inflight.delete(key); }
  }
}

function fetchRange(column: string, range: Range, priority: 'high'|'normal') {
  const key = `${column}:${range.start}-${range.end}`;
  if (inflight.has(key)) return;
  if (inflight.size >= MAX_CONCURRENCY && priority === 'normal') return;

  // Budget guard
  const span = range.end - range.start + 1;
  if (versesThisMinute + span > MAX_VERSES_PER_MIN) return;

  const ctl = new AbortController();
  inflight.set(key, ctl);
  versesThisMinute += span;

  loadVerses(column, range, { signal: ctl.signal }) // your existing loader
    .finally(() => inflight.delete(key));
}

// reset budget every minute
setInterval(() => { versesThisMinute = 0; }, 60_000);
```

---

## Main loop (rAF-throttled)

```ts
let isDragging = false;
let dragTimer: any = null;

function onScrollOrAnchorChange(anchor: number, vps: number, dir: 1|-1) {
  const now = performance.now();
  if (!shouldUpdate(now, anchor)) return;

  const bigJump = Math.abs(anchor - lastAnchor) >= BIG_JUMP_VERSES || isDragging;

  const window = computeWindow(anchor, vps, dir);
  lastUpdateTs = now;
  lastAnchor = anchor;

  if (bigJump) {
    // Hard reset to avoid stale work:
    for (const [, ctl] of inflight) ctl.abort();
    inflight.clear();
    // Render skeleton for window synchronously (main column only)
    renderSkeleton('main', window);
    // Load main column ASAP
    fetchRange('main', window, 'high');
    // Thin halo for xrefs/prophecy AFTER main resolves (schedule microtask)
    queueMicrotask(() => {
      const halo = { start: Math.max(1, window.start - PREFETCH_XREF_MARGIN),
                     end: window.end + PREFETCH_XREF_MARGIN };
      fetchRange('xrefs', halo, 'normal');
      fetchRange('prophecy', halo, 'normal');
    });
    return;
  }

  // Normal scroll path:
  cancelInflightOutside(window);

  // 1) Always ensure main text inside window
  fetchRange('main', window, 'high');

  // 2) Prefetch next lead slice only (not the whole 200–500)
  const dirLead = dir === 1
    ? { start: window.end + 1, end: window.end + Math.min(LEAD_BASE, 80) }
    : { start: Math.max(1, window.start - Math.min(LAG_BASE, 50)), end: window.start - 1 };

  if (dirLead.start <= dirLead.end) fetchRange('main', dirLead, 'normal');

  // 3) Secondary columns for visible window + tiny halo
  const halo = { start: Math.max(1, window.start - PREFETCH_XREF_MARGIN),
                 end: window.end + PREFETCH_XREF_MARGIN };
  fetchRange('xrefs', halo, 'normal');
  fetchRange('prophecy', halo, 'normal');
}

// Wire drag pause/resume
function onScrollbarDragStart() {
  isDragging = true;
  // pause scheduling; existing calls will be canceled by bigJump path on release
}
function onScrollbarDragEnd(finalAnchor: number) {
  if (dragTimer) clearTimeout(dragTimer);
  dragTimer = setTimeout(() => { isDragging = false; }, DRAG_PAUSE_MS);
  // Force an immediate recompute to final position
  onScrollOrAnchorChange(finalAnchor, V3, 1); // treat as very fast to bias lead
}
```

---

## Request de-dupe + Abort in your loader

Make sure your underlying `loadVerses()` respects AbortController and **chunk-coalesces** ranges to your storage format (e.g., fetch by file chunk, not verse-by-verse), then slices locally.

---

## Priority pipeline

1. **Main translation (visible window)** → render immediately (fills “—” first).
2. **Main translation (lead slice)** → small, directional prefetch.
3. **Xrefs + Prophecy (visible + small halo)** → after main resolves.
4. **Never** “thousands ahead” for secondary columns.

---

## LRU cache with soft cap

Keep an LRU keyed by `translation:verse` with `CACHE_SOFT_LIMIT_ROWS`. When exceeding, drop **behind** first (far older rows), keep near-future lead.

---

## Sanity limits (prevents 1.5 GB spikes)

* Global **MAX\_VERSES\_PER\_MIN** (above) plus a **per-column multiplier** (e.g., xrefs/prophecy counted as 0.5 each).
* Hard **MAX\_CONCURRENCY** per column stream.
* **Backoff** if network errors/timeouts (exponential backoff per column).

---

## Logging you can trust (copy/paste)

Replace “MASSIVE BUFFER ALWAYS AHEAD” with structured numbers:

```
APV tick:
  anchor=13102 dir=→ vps=26
  window=[13050..13280] visible=40 lead=170 lag=20
  inflight: main=[13050..13280], prefetch=[13281..13340], xrefs=[13040..13290], prophecy=[13040..13290]
  concurrency=3 verses/min=820 budget=4000
```

On big jumps:

```
APV jump:
  from=310 to=11980 Δ=11670 (drag end)
  abort_inflight=7
  skeleton: main=[11960..12060]
  enqueue: main(high), xrefs+prophecy(halo)
```

---

## Quick test matrix (use these to verify)

1. **Slow scroll** (mouse wheel): main never shows “—”; network stays < **500 verses/min**.
2. **Fast swipe** (trackpad): lead expands smoothly; no request explosion; no dropped frames.
3. **Scrollbar drag 10k verses**: old inflight aborted; main window painted within 1–2 frames; extras arrive after.
4. **Mobile low-RAM**: no OOM; memory plateaus thanks to LRU & soft caps.
5. **Toggle xrefs/prophecy ON** mid-scroll: main unaffected; secondaries fill opportunistically.
6. **Offline/timeout**: retries back off; UI shows cached + skeleton without thrash.

---

## Minimal patch checklist (what to change right now)

* [ ] Remove fixed “200–500 verse” buffers and “every 5 verses” triggers.
* [ ] Add **velocity-aware** window `computeWindow()`.
* [ ] Add **throttled scheduler** with `shouldUpdate()` and **abort+cancellation**.
* [ ] Prioritize **main visible**, then **small lead**, then **secondaries**.
* [ ] Implement **BIG\_JUMP** & **drag pause** paths.
* [ ] Enforce **MAX\_CONCURRENCY** and **verses/min budget**.
* [ ] Add **LRU cache** soft limit, evict tail first.
* [ ] Replace logs with **APV tick/jump** structured lines.

If you paste your current `onScroll`/scheduler and loader function names, I can tailor the above into exact diff blocks against your files (e.g., `VirtualBibleTable.tsx`, `useBibleStore.ts`, `dataLoader.ts`).
