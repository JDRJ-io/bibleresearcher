Here’s a clean spec you can hand to the AI agent that (1) defines what “centered” actually means for your table, (2) explains what’s happening in the screenshots, and (3) tells it how to fix/verify — without making code changes yet.

# What “centered” must mean (precise)

There are **three different centers** that must not be confused:

1. **Viewport center (VP-C):** the midpoint of the visible browser area.
   `VP-C = scrollLeft + viewportWidth / 2`

2. **Table center (TB-C):** the midpoint of the entire scrolled table area (all columns currently rendered in the row list).
   `TB-C = tableLeft + tableWidth / 2`

3. **Column-track center (CT-C\[k]):** the center line of **each column track k** (the slot).
   If a column k starts at pixel `x_k` and has width `w_k`,
   `CT-C[k] = x_k + w_k / 2`

> **True alignment rule:** For each slot `k`, the **header cell** and **body cells** must share the **same column-track geometry**:

* Header’s **container** width = Body’s **container** width = the track width `w_k`
* The header text baseline and the body content baseline both run under the same **center line CT-C\[k]**

Said another way: if you drop a vertical hairline at `CT-C[k]`, it should bisect the header and the body cells for that column in **every row**.

# What the screenshots show (why it looks “off”)

From the images:

* The **header row** and the **body grid** do not share one authoritative width system. Some columns (e.g., prophecy) are sized by **variable-driven inline calc()** and **obey the multiplier**, while others (reference, KJV, alt translations, occasionally notes/x-refs) still carry **fixed Tailwind widths** (`w-20`, `w-80`) or min-width/flex-basis constraints.
  **Effect:** each column’s **intrinsic** width is being decided at two places (header vs body). The grid uses `grid-auto-columns: max-content`, so **the innermost child’s fixed width wins** and creates drift.

* When you **resize the browser**, media queries recompute and sometimes mask the drift (everything “recenters”). When you **use the menu control**, only the CSS variables change; the fixed classes don’t, so some columns move while others don’t. That’s why prophecy looks right and others don’t.

* In a couple of shots you can see **gutter mismatches**: the space between columns in the header doesn’t match the space between the same columns in the body. That’s the telltale sign of **two grids** (or two sizing systems) not sharing the same track template.

# How to define/diagnose alignment for the agent (no edits yet)

## A) Instrument the centers (read-only)

Have the agent add a temporary **diagnostic overlay** (can be a devtools snippet, not committed) that draws a 1px vertical line at:

* `VP-C` (viewport center)
* `TB-C` (table center)
* `CT-C[k]` for each visible column `k`

Confirm:

* `CT-C[k]` for header equals `CT-C[k]` for body (they currently don’t for some columns).
* Whether `TB-C` coincides with the **visual center** you expect. (It may not; that’s okay. We care about columns aligning to **their own** centers, not to viewport center.)

## B) Snapshot geometry (header vs body)

For 3 representative columns (Reference, KJV, Prophecy):

* Log `x_k` and `w_k` for the **header** container and the **body** container at the same slot index.
* If `x` or `w` differ across header/body for the same slot, you’ve proven misalignment.

## C) Class/var audit per slot

For the same three columns, list:

* Header wrapper classes (look for `w-*`, `min-w-*`, `basis-*`, `flex-none`).
* Body wrapper classes (same).
* Whether either wrapper uses an **inline style width** referencing `--col-*` or `--column-width-mult`.

You’ll see prophecy using var-based inline width and the others using fixed Tailwind widths — that’s why prophecy tracks the control and the others don’t.

# Spec the **correct** centering logic (what “true center” looks like)

1. **Single track authority:** both header and body for slot `k` must size from **the same CSS variable**:
   `width(min-width, flex-basis) = var(--col-<type>)`,
   where `--col-<type> = calc(var(--col-<type>-base) * var(--column-width-mult))`.

2. **Apply on the track-governing wrapper:** the element that the grid/flex uses to compute the column’s intrinsic width **must** be the one that has this width. No inner child may have a competing `w-*`/`min-w-*`/`basis-*`.

3. **One grid template for both header and body:** if you keep `grid-auto-columns: max-content`, the intrinsic width must be the **variable-driven** value in **both** header and body. If you use an explicit `grid-template-columns`, it must be computed from those same `--col-*` variables for **both**.

4. **No fixed Tailwind widths where track size is derived:** remove `w-20`, `w-80`, `basis-80`, `flex-none`, etc., from track wrappers; padding/typography stays **inside**.

When this is true, the **true center** of a column (`CT-C[k]`) bisects both header and body content uniformly, and changing `--column-width-mult` moves **every** CT-C\[k] in lockstep.

# What to tell the agent to verify (before any refactor)

1. **Menu test (read-only):** change the menu width control and record `w_k` for three columns in header and body. Today you’ll see prophecy’s `w_k` change; others will not.
2. **Resize test:** resize the browser; you’ll see the clamp/media-query system nudge widths, masking the mismatch temporarily.
3. **Text centering ≠ column centering:** a header label centered with `text-center` is **not** proof of a centered column. The proof is **container width equality** header↔body and shared CT-C\[k].

# One-paragraph diagnosis (to include in your report)

> The table currently has **two competing width authorities**: variable-driven inline widths (used by prophecy columns and some containers) and fixed Tailwind widths/min-widths/flex-basis (used by reference, KJV, alt translations, etc.). Because the grid uses intrinsic sizing (`max-content`), the **innermost fixed width** wins, so header and body don’t share the same **column-track center lines**. Browser resize re-evaluates media queries/clamps, making it *look* centered, but the manual control only changes CSS variables, so only the prophecy columns move. **True center** means the header and body **track-governing wrappers** for each slot `k` read the **same** `--col-*` variable (multiplied by `--column-width-mult`), with no fixed widths on inner elements, yielding identical `CT-C[k]` in header and body.

If you want, I can give you a tiny devtools snippet that draws the CT-C hairlines so your agent can screenshot “before vs after” and prove the fix visually.
