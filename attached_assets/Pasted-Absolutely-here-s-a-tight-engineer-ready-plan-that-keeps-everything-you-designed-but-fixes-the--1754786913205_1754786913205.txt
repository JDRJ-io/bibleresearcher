Absolutely—here’s a tight, engineer-ready plan that **keeps everything you designed** but fixes the “how” so scrolling stays butter-smooth. I’ll hit each bottleneck you listed, then give drop-in patches.

---

# Prioritized fixes (what to change + why)

1. **Kill the polling width checker**
   Current: `setInterval(..., 250)` + `getComputedStyle` + `querySelectorAll` every 250ms.
   Fix: **ResizeObserver** (and optionally **MutationObserver** on column visibility) so we react only when width truly changes.

2. **Silence render-path logging**
   Current: console logs in `LabeledText`, `useViewportLabels`, `useAdaptivePortraitColumns`, `VirtualRow`.
   Fix: gated logger with levels, tree-shakable in prod; lazy message construction to avoid string concat cost.

3. **Make viewport label expansion O(1) per verse**
   Current: nested loops over cross-refs/prophecy sets on every viewport change.
   Fix: precompute **index → refs** maps once; memoize window results; optionally move expansion to a **Web Worker** for zero main-thread jank.

4. **Eliminate repeated DOM queries**
   Current: `document.querySelectorAll('.cell-ref')` and repeated `getComputedStyle`.
   Fix: pass **refs** from the table layout (or a single column container ref); never query the whole doc; use `offsetWidth` or `clientWidth` instead of `getComputedStyle` when possible.

5. **Unify scroll scheduling**
   Current: multiple modules use `requestAnimationFrame` independently, stacking work during fast scrolls.
   Fix: a single **scroll RAF bus**: one passive `scroll` listener per scroll container, one RAF per frame, fan out to subscribers.

6. **Row render minimization**
   Current: multiple `VirtualRow` logs/renders.
   Fix: `React.memo` rows; stable props; selectors that only pull the visible window; avoid passing new object literals each render.

7. **Defer non-critical tasks**
   Use `requestIdleCallback` (or a `setTimeout(0)` fallback) for low-priority bookkeeping after scroll settles; keep the main thread free during interaction.

---

# Drop-in patches

## 1) Replace interval width monitor with observers

```ts
// useReferenceColumnWidth.ts
import * as React from 'react';

type Opts = {
  /** The column container that actually resizes (NOT every cell). */
  columnRef: React.RefObject<HTMLElement>;
  /** Called when the effective reference column width changes. */
  onWidth: (px: number) => void;
  /** Optional: element whose children (columns) can mount/unmount. */
  columnsHostRef?: React.RefObject<HTMLElement>;
};

export function useReferenceColumnWidth({ columnRef, onWidth, columnsHostRef }: Opts) {
  const last = React.useRef<number | null>(null);

  React.useEffect(() => {
    const el = columnRef.current;
    if (!el) return;

    const emit = () => {
      // Prefer layout reads over computed style for speed
      const w = Math.round(el.clientWidth); // or el.offsetWidth
      if (w !== last.current) {
        last.current = w;
        onWidth(w);
      }
    };

    // ResizeObserver: runs only on actual size changes
    const ro = new ResizeObserver(() => emit());
    ro.observe(el);

    // Optional: if columns mount/unmount or class toggles might affect layout
    let mo: MutationObserver | null = null;
    if (columnsHostRef?.current) {
      mo = new MutationObserver(() => emit());
      mo.observe(columnsHostRef.current, { childList: true, subtree: true, attributes: true });
    }

    // Initial measure
    queueMicrotask(emit);

    return () => {
      ro.disconnect();
      mo?.disconnect();
    };
  }, [columnRef, onWidth, columnsHostRef]);
}
```

**Notes**

* No polling. No global queries. One `clientWidth` read per actual change.
* If you previously read CSS variables, move those variables to the column element itself and still read `clientWidth`—it’s cheaper.

---

## 2) Production-safe, lazy logger

```ts
// logger.ts
export type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'debug';

const LEVEL: LogLevel =
  (import.meta as any).env?.MODE === 'production' ? 'silent' : 'warn'; // adjust as you like

const order: Record<LogLevel, number> = { silent: 5, error: 1, warn: 2, info: 3, debug: 4 };

export const log = {
  debug: (ns: string, msg: () => any) => {
    if (order[LEVEL] <= order.debug) console.debug(`[${ns}]`, msg());
  },
  info:  (ns: string, msg: () => any) => {
    if (order[LEVEL] <= order.info) console.info(`[${ns}]`, msg());
  },
  warn:  (ns: string, msg: () => any) => {
    if (order[LEVEL] <= order.warn) console.warn(`[${ns}]`, msg());
  },
  error: (ns: string, ...args: any[]) => {
    if (order[LEVEL] <= order.error) console.error(`[${ns}]`, ...args);
  },
};
```

**How to use (lazy):**

```ts
log.debug('useViewportLabels', () => ({ start, end, expandedCount }));
```

No string building unless the level allows it. In prod, set `LEVEL='silent'`.

---

## 3) Viewport label expansion that scales

**Precompute maps once** (on data load):

```ts
// labelIndex.ts
export type VerseIdx = number; // your canonical index
export type VerseKey = string; // 'Book.Ch:Vs'

export type CrossMap = Map<VerseIdx, VerseIdx[]>;   // idx -> related idx array
export type ProphecyMap = Map<VerseIdx, VerseIdx[]>;

export function buildIndexMaps(dataset: {
  crossRefs: Array<[VerseIdx, VerseIdx[]]>;
  prophecies: Array<[VerseIdx, VerseIdx[]]>;
}): { cross: CrossMap; proph: ProphecyMap } {
  const cross = new Map(dataset.crossRefs);
  const proph = new Map(dataset.prophecies);
  return { cross, proph };
}
```

**Use O(1) expansion per verse for the visible window:**

```ts
// useViewportLabels.ts
import * as React from 'react';
import { log } from './logger';
import { CrossMap, ProphecyMap, VerseIdx } from './labelIndex';

type Opts = {
  windowStart: VerseIdx;
  windowEnd: VerseIdx;
  cross: CrossMap;
  proph: ProphecyMap;
};

export function useViewportLabels({ windowStart, windowEnd, cross, proph }: Opts) {
  // Memoize the exact result for this window
  return React.useMemo(() => {
    const expanded: VerseIdx[] = [];
    for (let i = windowStart; i <= windowEnd; i++) {
      expanded.push(i);
      const c = cross.get(i);
      if (c) expanded.push(...c);
      const p = proph.get(i);
      if (p) expanded.push(...p);
    }
    // Optional: dedupe with a tiny bitmap/Set if needed
    // const uniq = Array.from(new Set(expanded));
    log.debug('useViewportLabels', () => ({
      windowStart, windowEnd, added: expanded.length,
    }));
    return expanded;
  }, [windowStart, windowEnd, cross, proph]);
}
```

**Optional worker offload** (same algorithm, but off main thread) if expansion volume spikes; you can post `windowStart/end` and get back the list.

---

## 4) Ditch global DOM queries

Where you have:

```ts
document.querySelectorAll('.cell-ref') // ❌
getComputedStyle(el).getPropertyValue('--something') // ❌ hot path
```

Replace with:

* A **single ref** to the reference column container, passed into `useReferenceColumnWidth`.
* Read **layout** (`clientWidth` / `offsetWidth`) instead of computed styles.
* If you must read a CSS variable, read it **once on theme change**, not per scroll/frame. Keep the current theme in state and re-read only when it flips.

---

## 5) One scroll → one RAF → many subscribers

```ts
// useRafScrollBus.ts
import * as React from 'react';

type Subscriber = (e: { scrollTop: number; clientHeight: number; scrollHeight: number }) => void;

export function useRafScrollBus(scrollRef: React.RefObject<HTMLElement>) {
  const subs = React.useRef(new Set<Subscriber>());
  const raf = React.useRef<number | null>(null);

  React.useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const onScroll = () => {
      if (raf.current != null) return;
      raf.current = requestAnimationFrame(() => {
        raf.current = null;
        const payload = {
          scrollTop: el.scrollTop,
          clientHeight: el.clientHeight,
          scrollHeight: el.scrollHeight,
        };
        subs.current.forEach(fn => fn(payload));
      });
    };

    el.addEventListener('scroll', onScroll, { passive: true });
    return () => el.removeEventListener('scroll', onScroll);
  }, [scrollRef]);

  const subscribe = React.useCallback((fn: Subscriber) => {
    subs.current.add(fn);
    return () => subs.current.delete(fn);
  }, []);

  return { subscribe };
}
```

**Usage idea:** `useSmartScroll`, thumb placement, “center anchor” calculations, and any lightweight view math **subscribe** to this bus instead of each attaching their own RAF.

---

## 6) Virtual row stability

```ts
// VirtualRow.tsx
import * as React from 'react';

type Props = {
  index: number;
  keyText: string;   // avoid passing the whole verse object
  // ...other primitive props
};

function RowInner({ index, keyText /* ... */ }: Props) {
  // render only; no logs in prod
  return /* row JSX */;
}

export const VirtualRow = React.memo(RowInner);
```

* Ensure parent doesn’t pass **new object/array literals** per render (lift them or memoize).
* If you select per-row data from global state, use a selector that returns **stable references** for unchanged rows.

---

## 7) Idle work after scroll settles

```ts
// useAfterScrollIdle.ts
import * as React from 'react';

export function useAfterScrollIdle(scrollRef: React.RefObject<HTMLElement>, onIdle: () => void, delay = 120) {
  const t = React.useRef<number | null>(null);

  React.useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const onScroll = () => {
      if (t.current) window.clearTimeout(t.current);
      t.current = window.setTimeout(() => {
        // Prefer requestIdleCallback when available
        const ric = (window as any).requestIdleCallback as undefined | ((cb: () => void) => number);
        if (ric) ric(onIdle);
        else setTimeout(onIdle, 0);
      }, delay);
    };

    el.addEventListener('scroll', onScroll, { passive: true });
    return () => {
      el.removeEventListener('scroll', onScroll);
      if (t.current) window.clearTimeout(t.current);
    };
  }, [scrollRef, onIdle, delay]);
}
```

Use this to start **non-critical** fetches, analytics, or prefetching after the user stops scrolling.

---

# Wiring notes specific to your concerns

* **“Normal scrolling via middle mouse / phone should not pause loading.”**
  Do **not** call `setMode('KeysOnly')` in any scroll listener. Only call it in the **thumb’s `pointerdown`** (your custom scrollbar). That keeps wheel/touch in `Full` mode 100% of the time.

* **Tooltip linked to center anchor verse**
  Keep your current center-index logic, but subscribe to the **scroll RAF bus** so it runs once per frame. Show the tooltip only while `mode === 'KeysOnly'` (thumb drag).

* **Theme/CSS variable reads**
  If any logic depends on CSS variables, re-read them **on theme change** (or window resize if truly needed)—not per scroll.

* **Cross-ref/prophecy expansion**
  The O(1) map + memo approach above preserves your exact behavior but eliminates nested loops per scroll. If your dataset is large, move that expansion to a worker for extra headroom.

---

# What this removes (measurable wins)

* 4x/second global DOM sweeps → **0** during idle (only on actual resizes/mounts).
* Multiple RAFs per frame → **1** RAF per scroll container per frame.
* Render-path logging → **no-ops** in production; lazy logs in dev only.
* `getComputedStyle` in hot path → **layout width reads** (faster) only on change.
* Repeated querySelectorAll → **no global queries**, refs only.

---

If you want, I can generate a **PR-style patch** for your filenames (e.g., `useReferenceColumnWidth.ts`, `useViewportLabels.ts`, `useSmartScroll.ts`, `VirtualRow.tsx`) so your engineer can paste it in with minimal diff churn.
