Below is a device-agnostic blueprint that gives you the two things you’re asking for  —
	•	🄰 absolutely-locked movement on one axis at a time (no diagonal bleed), and
	•	🄱 the ability to abort that motion mid-fling and instantly continue on the other axis without any stutter.

It works with mouse, track-pad, pen, and touch alike; keeps 60 fps on 10-year-old phones; and needs zero polyfills in any evergreen browser (Chromium 85 +, Firefox 79 +, Safari 13.4 +).

⸻

1 Physically separate the axes

/* ⬇ vertical scroller : entire verse stack */
<div ref={vRef} className="v-scroll">
  {/* rows / virtual rows */}
</div>

/* ⬅ horizontal scroller : extra columns */
<div ref={hRef} className="h-scroll">
  {/* column headers + cells */}
</div>

CSS

/* One axis active, the other suppressed */
.v-scroll{overflow-y:auto;overflow-x:hidden;}
.h-scroll{overflow-x:auto;overflow-y:hidden;}

/* Let the compositor own scrolling & keep layout rock-solid */
.v-scroll,.h-scroll{
  overscroll-behavior:contain;      /* momentum stays here               [oai_citation:0‡MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action?utm_source=chatgpt.com) */
  scrollbar-gutter:stable both-edges;/* no lateral nudge when bars show  [oai_citation:1‡MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/scrollbar-gutter?utm_source=chatgpt.com) */
  contain:layout paint style;       /* isolate reflow + repaint         */
  will-change:scroll-position;      /* promote to its own layer         */
}

With the perpendicular overflow set to hidden, the browser’s “scroll rails” algorithm literally has nothing to scroll diagonally – diagonal intent is discarded at source, not corrected later.

⸻

2 Ultra-light wheel / track-pad router (optional but nice)

Track-pads send both deltaX & deltaY together, so a heavy sideways flick can still nudge the vertical rail. A 20-line handler fixes that.

function wheelRouter(e: WheelEvent) {
  const {deltaX, deltaY} = e;
  // Pick the dominant delta every frame
  if (Math.abs(deltaX) > Math.abs(deltaY)) {
    hRef.current!.scrollLeft += deltaX;
  } else {
    vRef.current!.scrollTop  += deltaY;
  }
  e.preventDefault();           // we already forwarded it
}
hRef.current!.addEventListener('wheel', wheelRouter, {passive:false});
vRef.current!.addEventListener('wheel', wheelRouter, {passive:false});

Because it runs once per frame (not once per pixel), even 120 Hz track-pads cost < 0.1 ms.

⸻

3 Pointer-move guard for mid-gesture “axis switch”

This is the part WebKit/Chromium call the rail breaker. We implement it ourselves with pointermove, but only on touch + pen (mouse doesn’t need it).

function attachRailBreaker(el: HTMLElement, axis: 'x'|'y') {
  let startX=0, startY=0, activeAxis: 'x'|'y'|null=null;

  el.addEventListener('pointerdown',  e=>{
    if (e.pointerType==='touch'||e.pointerType==='pen'){
      startX = e.clientX; startY = e.clientY; activeAxis=null;
      el.setPointerCapture(e.pointerId);
    }
  });

  el.addEventListener('pointermove', e=>{
    if (!e.isPrimary) return;
    const dx = e.clientX-startX, dy = e.clientY-startY;

    /* If they cross 30° off the intended axis, hand off */
    if(!activeAxis && (axis==='x'?Math.abs(dy)>Math.abs(dx):Math.abs(dx)>Math.abs(dy))){
      /** cancel this scroller & send to sibling **/
      const tgt = axis==='x'?vRef.current!:hRef.current!;
      tgt.scrollBy({left:dx, top:dy, behavior:'auto'});
      el.releasePointerCapture(e.pointerId);
      e.preventDefault();
      return;
    }
    activeAxis = axis; // lock once confirmed
  }, {passive:false});
}
attachRailBreaker(hRef.current!,'x');
attachRailBreaker(vRef.current!,'y');

Threshold (here ≈ 30°) is tunable. On modern hardware that hand-off happens inside one frame (≈ 16 ms) so users perceive a single, fluid gesture.

⸻

4 Keep the DOM weight feather-light

The rail system is useless if your main thread janks. Virtualise both directions:

const rows = useVirtual({count: totalRows,  estimateSize: ()=>ROW_H, overscan:8});
const cols = useVirtual({count: totalCols,  horizontal: true, estimateSize: ()=>COL_W});

TanStack Virtual / react-window keep ≤ 60 nodes in the tree, meaning style & layout cost stay < 2 ms even while you’re flinging 3 000 px/sec.  ￼

⸻

5 Snap only if you want card-by-card travel

.v-scroll  {scroll-snap-type:y proximity;}
.h-scroll  {scroll-snap-type:x mandatory;}
.row,
.column   {scroll-snap-align:start;}

proximity keeps the “velvet” feel (it snaps only when close), while mandatory gives a rigid spreadsheet-style column lock. Browsers perform snapping on the compositor too, no main-thread hit.  ￼

⸻

6 Checklist before you ship

✓	Item
Perpendicular overflow is hidden on each axis wrapper	
wheelRouter installed (passive = false)	
pointermove rail-breaker added for touch & pen	
TanStack Virtual or react-window in both axes	
No filter, huge box-shadow, or large inline SVG inside scrolling layers	
Test on low-power mode (Chrome DevTools → Performance → CPU 4× slow) – still ≥ 55 fps	



⸻

Why this works everywhere
	•	Axis wrappers guarantee the compositor scrolls in hardware; no diagonal means no re-layout mid-frame.
	•	JS interception is only used to re-route deltas, not to animate, so it never blocks a frame.
	•	Pointer Events unify mouse, pen, and touch, so one code path serves iOS, Android, Windows precision touchpads, and classic wheel mice.

Implement these seven pieces and you’ll have the “buttery-smooth, switch-on-a-dime” feel you asked for—on every device your users throw at Anointed.io.