Below is the **end‑to‑end “mental model”** that turns the two raw files you store in `/references/` — `prophecy_rows.txt` and `prophecy_index.json` — into the three scrolling prophecy columns that look like the mock‑up you sent:

---

### 1   In‑memory data structures

| Purpose                                                                                                                                  | Source file           | Shape after parsing                                                                                                                                                      |
| ---------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Verse→Role→IDs** Which prophecy IDs touch a verse and whether each appearance is a Prediction (P), Fulfilment (F) or Verification (V). | `prophecy_rows.txt`   | `ts type RoleMap = {P:number[]; F:number[]; V:number[]}  const verseRoles: Record<string,RoleMap>`                                                                       |
| **ID→Details** Human summary plus the full verse lists for each role.                                                                    | `prophecy_index.json` | `ts interface ProphecyIdxEntry { summary:string; prophecy:string[]; fulfillment:string[]; verification:string[] }  const prophecyIndex: Record<number,ProphecyIdxEntry>` |

*(Both objects are filled once by a worker thread and kept in a global cache so they never block the UI again.)*

---

\### 2   Slice loader: bringing prophecy slices into React state

```ts
/** Verse IDs currently in the viewport */
const [visible, setVisible] = useAnchorSlice(...).verseIDs;

/** Redux / Zustand style store */
useProphecySliceLoader(visible);   // Hook runs in a worker
```

* Worker looks at every `verseID` in `visible`
* Collect **all** prophecy IDs mentioned under any role
* Pull the full `ProphecyIdxEntry` objects for those IDs
* Push the result into `store.propheciesSlice` shaped as

```ts
store.prophecies = {
  // keyed by ID for O(1) lookup at render time
  [128]: { summary:'…', P:['1Chr.11:1'], F:['1Chr.11:3'], V:['1Chr.10:13',…] },
  [129]: …
}
```

Because the hook only re‑runs when the slice changes, there is **no per‑row fetch** and scrolling stays \~O(1).

---

\### 3   Row component decides *which* prophecy IDs belong in *this* row

```tsx
const roles = verseRoles[verse.reference]   // {P:[], F:[], V:[128,134]}

const ids = roles.P.concat(roles.F, roles.V)   // unique list for that verse
```

> *If the verse plays more than one role the lists overlap, but that’s fine – we only need the IDs to fetch the `summary` in the next step.*

---

\### 4   Rendering the **three fixed prophecy columns**

1. **Group by ID** so every prophecy renders as a block:

```ts
const grouped = ids.reduce((acc,id)=>{
  const entry = store.prophecies[id];
  if (!entry) return acc;        // still streaming – show spinner
  acc[id] ??= { summary: entry.summary, P:[],F:[],V:[] };
  if (roles.P.includes(id)) acc[id].P.push(verse.reference);
  if (roles.F.includes(id)) acc[id].F.push(verse.reference);
  if (roles.V.includes(id)) acc[id].V.push(verse.reference);
  return acc;
},{} as Record<number,{summary:string,P:string[],F:string[],V:string[]}>);
```

2. **For each ID, paint a mini‑table** that spans the three cells side‑by‑side:

```tsx
Object.values(grouped).map((block,i)=>(
  <Fragment key={i}>
    {/* the thin summary bar stretches over all three cells via CSS grid */}
    <div className="prophecy-summary" style={{gridColumn:'1 / -1'}}>
      {block.summary}
    </div>

    {/* prediction column */}
    <div className="prophecy-cell">{block.P.map(link)}</div>

    {/* fulfilment column */}
    <div className="prophecy-cell">{block.F.map(link)}</div>

    {/* verification column */}
    <div className="prophecy-cell">{block.V.map(link)}</div>
  </Fragment>
))
```

* `link(ref)` prints the blue **Gen 2 : 17** style link and, under it, the verse text fetched from the global translation cache.
* Because every ID is rendered once per row, users can scroll inside a prediction cell and immediately hit the next `summary` divider if another prophecy also touches that verse.

---

\### 5   Scroll & performance guarantees

* **Only the currently‑visible verses** determine which IDs are loaded, so the prophecy columns never allocate more DOM than one viewport slice.
* Verse texts come from the same shared *translation cache* the other columns already use → **no extra network round‑trips**.
* Worker parsing happens once at startup (≈ 70 ms for 4 k prophecies) and is **streamed** into the store so first paint is not blocked.

---

## What to wire up next

| Task                                                       | File / hook                                      | Status                                                    |
| ---------------------------------------------------------- | ------------------------------------------------ | --------------------------------------------------------- |
| Worker that parses *prophecy\_rows.txt* → `verseRoles`     | `src/workers/prophecyRowsParser.ts`              | already merged                                            |
| Worker that loads *prophecy\_index.json* → `prophecyIndex` | `src/workers/prophecyIndexLoader.ts`             | already merged                                            |
| React hook `useProphecySliceLoader(verseIDs)`              | `src/hooks/useProphecySliceLoader.ts`            | ✅                                                         |
| Row‑level component logic above                            | `VirtualRow.tsx` (inside `renderSlot` for P/F/V) | **← add this block grouping logic**                       |
| Grid/CSS for summary bar that spans 3 cells                | `ProphecyColumns.css`                            | add `display:grid; grid-template-columns: repeat(3,1fr);` |

After those four pieces are in, the prophecy section will match the picture you sent: one compact header line plus the P / F / V verses stacked inside their dedicated columns — and it will keep up with 100 fps scrolling because everything heavy runs outside the React render loop.

Feel free to drop this straight into the agent as your spec; nothing in the doc set needs to change.
