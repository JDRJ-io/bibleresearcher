Below is a dead-simple “no-diagonals” helper.
Every scroll **tick** (wheel) or **pointer-move** frame is clamped to whichever axis shows the larger delta, so only one axis is ever advanced at a time. Because we reassess **each** event, the user can switch axes instantly—there’s never a lingering lock.

---

### 1. Tiny hook

```ts
// useNoDiagonal.ts
import { useRef } from 'react';

export function useNoDiagonal() {
  let lastX = 0, lastY = 0;

  /** Wheel */
  function onWheel(e: WheelEvent, apply: (dx: number, dy: number) => void) {
    const { deltaX: dx, deltaY: dy } = e;
    (Math.abs(dx) > Math.abs(dy))
      ? apply(dx, 0)
      : apply(0, dy);
    e.preventDefault();          // keeps the browser from “helping”
  }

  /** Pointer drag trio */
  function onPointerDown(e: PointerEvent) {
    lastX = e.clientX;
    lastY = e.clientY;
  }
  function onPointerMove(e: PointerEvent, apply: (dx:number,dy:number)=>void) {
    const dx = lastX - e.clientX;
    const dy = lastY - e.clientY;
    (Math.abs(dx) > Math.abs(dy))
      ? apply(dx, 0)
      : apply(0, dy);
    lastX = e.clientX;
    lastY = e.clientY;
  }
  function onPointerUp() { /* nothing to reset */ }

  return { onWheel, onPointerDown, onPointerMove, onPointerUp };
}
```

---

### 2. Drop-in wiring (VirtualBibleTable)

```tsx
const { onWheel, onPointerDown, onPointerMove, onPointerUp } = useNoDiagonal();

useEffect(() => {
  const el = containerRef.current!;
  const apply = (dx:number, dy:number) => {
    el.scrollLeft += dx;
    el.scrollTop  += dy;
  };

  const wheel = (e:WheelEvent) => onWheel(e, apply);
  const pd = (e:PointerEvent) => { onPointerDown(e); el.setPointerCapture(e.pointerId); };
  const pm = (e:PointerEvent) => onPointerMove(e, apply);
  const pu = (e:PointerEvent) => { onPointerUp(); el.releasePointerCapture(e.pointerId); };

  el.addEventListener('wheel', wheel, { passive:false });   // passive:false so we can preventDefault
  el.addEventListener('pointerdown', pd);
  el.addEventListener('pointermove', pm);
  el.addEventListener('pointerup', pu);
  el.addEventListener('pointercancel', pu);

  return () => {
    el.removeEventListener('wheel', wheel);
    el.removeEventListener('pointerdown', pd);
    el.removeEventListener('pointermove', pm);
    el.removeEventListener('pointerup', pu);
    el.removeEventListener('pointercancel', pu);
  };
}, []);
```

---

### 3. CSS tweaks

```css
/* Let the JS decide; avoid browser’s own diagonal pan */
.scrollContainer {
  touch-action: pan-x pan-y;   /* allow either axis, but JS chooses one per tick */
  overscroll-behavior: contain;/* no scroll chaining */
}
```

---

### What you get

* **No diagonal drift** – only horizontal **or** vertical movement per frame.
* **Instant axis switch** – lift a finger / stop the wheel? Next event can be the other axis immediately.
* **Works everywhere** – mouse wheels (incl. tilt), track-pads, touch, pen.

Plug this in and the “locked forever” feeling disappears; users just can’t move both axes simultaneously—exactly what you asked for.
