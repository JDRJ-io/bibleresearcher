Below is a **check‑list plus drop‑in code** that will complete the last 5 % and wire a Web Worker into the exact data‑flow you described. Follow it top‑to‑bottom; each step names the file(s) you already have in your stack.

---

## 0 Bird’s‑eye wiring diagram (after the upgrade)

```mermaid
graph TD;
  A[LabelsLegend.tsx<br>toggleLabel('who')] --> B[App.tsx<br>activeLabels store]
  B --> C[useViewportLabels.ts hook]
  C -->|needs labels| D[labelsCache.ts<br>ensureLabelCacheLoaded()]
  D -->|post msg| E(worker.js<br>fetch + stream‑parse + filter)
  E -->|filtered map| D
  D --> C
  C --> F[VerseRow.tsx<br>getVerseLabels → bitmask segmenter]
  F --> G[LabeledText.tsx render spans]
```

*Green arrows show the only two main‑thread/worker crossings.*

---

## 1 LabelBits enum (shared util)

**`labelBits.ts`**

```ts
export enum LabelBits {
  who        = 1 << 0,
  what       = 1 << 1,
  when       = 1 << 2,
  where      = 1 << 3,
  command    = 1 << 4,
  action     = 1 << 5,
  why        = 1 << 6,
  seed       = 1 << 7,
  harvest    = 1 << 8,
  prediction = 1 << 9,
}
export type LabelMask = number; // 0‑1023
export const allLabelNames = Object.keys(LabelBits) as (keyof typeof LabelBits)[];
```

---

## 2 Worker implementation (fetch + filter + cache)

**`labels.worker.ts`**  (👈 compile with `next‑worker`, Vite, or webpack’s worker‑loader)

```ts
import { LabelBits } from './labelBits';

// In‑worker cache so we never fetch/parse the same translation twice
const fileCache: Record<string, Record<string, any>> = {};  // {KJV:{Gen.1:1:{…}}}

self.onmessage = async (e: MessageEvent) => {
  const { tCode, active } = e.data as { tCode: string; active: (keyof typeof LabelBits)[] };

  if (!fileCache[tCode]) {
    // 1) FETCH – 1 URL per translation
    const url = `${self.location.origin}/api/labels/${tCode}/all.json`;  // Supabase is proxied
    const res = await fetch(url, { cache: 'force-cache' });             // honour CDN
    const raw = await res.text();

    // 2) PARSE (blocking inside Worker, safe for UI)
    fileCache[tCode] = JSON.parse(raw);
  }
  const src = fileCache[tCode];

  // 3) FILTER to active labels only -> dramatically smaller object
  const wanted = new Set(active);
  const filtered: Record<string, Record<string, string[]>> = {};
  for (const [vKey, entry] of Object.entries(src)) {
    const slim: Record<string, string[]> = {};
    wanted.forEach(lbl => {
      if (entry[lbl]?.length) slim[lbl] = entry[lbl];
    });
    if (Object.keys(slim).length) filtered[vKey] = slim;
  }

  // 4) POST back to main thread
  postMessage({ tCode, filtered });
};
```

---

## 3 Main‑thread cache wrapper

**`labelsCache.ts`**

```ts
import { LabelBits } from './labelBits';

type SlimEntry = Record<keyof typeof LabelBits, string[]>;
type SlimMap   = Record<string /*verse*/, Partial<SlimEntry>>;

const worker = new Worker(new URL('./labels.worker.ts', import.meta.url), { type: 'module' });

const cache: Record<string /*tCode*/, SlimMap|undefined> = {};
let pending = new Map<string, Promise<void>>();  // de‑dupes concurrent calls

export function ensureLabelCacheLoaded(
  tCode: string,
  activeLabels: (keyof typeof LabelBits)[]
): Promise<void> {

  if (cache[tCode] && activeLabels.every(l => someVerseHasLabel(cache[tCode]!, l)))
    return Promise.resolve();

  // de‑dupe
  const key = `${tCode}|${activeLabels.sort().join()}`;
  if (pending.has(key)) return pending.get(key)!;

  const p = new Promise<void>((resolve) => {
    const handle = (e: MessageEvent) => {
      if (e.data.tCode !== tCode) return;
      cache[tCode] = { ...cache[tCode], ...e.data.filtered };  // merge
      worker.removeEventListener('message', handle);
      pending.delete(key);
      resolve();
    };
    worker.addEventListener('message', handle);
    worker.postMessage({ tCode, active: activeLabels });
  });

  pending.set(key, p);
  return p;
}

export function getLabelsForVerses(
  tCode: string,
  verseKeys: string[],
  active: (keyof typeof LabelBits)[]
): SlimMap {
  const map = cache[tCode] || {};
  const result: SlimMap = {};
  verseKeys.forEach(v => {
    const entry = map[v];
    if (!entry) return;
    const filtered: Partial<SlimEntry> = {};
    active.forEach(lbl => { if (entry[lbl]) filtered[lbl] = entry[lbl]; });
    if (Object.keys(filtered).length) result[v] = filtered;
  });
  return result;
}

function someVerseHasLabel(map: SlimMap, lbl:keyof typeof LabelBits){
  return Object.values(map).some(ent => ent[lbl]);
}
```

*The cache now contains **only the labels that have ever been activated** for that translation.*

---

## 4 Hook change: pass activeLabels into cache loader

**`useViewportLabels.ts`**

```ts
useEffect(() => {
  if (activeLabels.length === 0) return;

  ensureLabelCacheLoaded(mainTranslation, activeLabels)
    .then(() => {
      const viewportLabels = getLabelsForVerses(
        mainTranslation,
        verseKeys,
        activeLabels
      );
      setViewportLabels(viewportLabels);  // local state or context
    });
}, [activeLabels.join(), mainTranslation, verseKeys.join('|')]);
```

> **Why `.join()` in deps?** Ensures React detects array content changes without re‑creating separate arrays every render.

---

## 5 Verse‑side: build the bitmask and segment only once

**`VerseRow.tsx`** (only the critical lines)

```tsx
import { LabelBits } from '../labelBits';

const maskFromEntry = (entry: Record<string,string[]> | undefined): number => {
  let m = 0;
  if (!entry) return 0;
  for (const lbl of Object.keys(entry) as (keyof typeof LabelBits)[]){
    m |= LabelBits[lbl];
  }
  return m;
};

const VerseRow: React.FC<{ verseKey:string; verseText:string }> = React.memo(({ verseKey, verseText }) => {
  const { viewportLabels } = useContext(LabelCtx);          // injected by table
  const entry   = viewportLabels[verseKey];
  const mask    = maskFromEntry(entry);

  const segments = useMemo(
    () => computeSegmentsCached(verseText, entry, mask),     // your bitmap logic
    [verseText, mask]                                        // stable unless labels diff
  );

  return (
    <>
      {segments.map(seg =>
        seg.mask
          ? <span key={seg.start + '-' + seg.mask} className={classesForMask(seg.mask)}>
              {verseText.slice(seg.start, seg.end)}
            </span>
          : verseText.slice(seg.start, seg.end)
      )}
    </>
  );
});
```

---

## 6 Supabase / CDN settings (once)

1. **Bucket public caching**

   * Project ➜ Storage ➜ Buckets ➜ **anointed** ➜ CORS/Cache rules
   * `Cache‑Control: public, max‑age=31536000, immutable`

2. **Enable Brotli/gzip**
   Supabase’s global CDN auto‑compresses `application/json`.

---

Implement these six file changes and you’ll have:

* **One JSON file per translation** (ease of maintenance, best compression).
* **Zero main‑thread blocking** (Worker does fetch + parse).
* **RAM stable** even with many labels active (filtered cache + bitmap).
* **Instant toggles** after the first Worker pass (all in‑memory).

That closes the last performance gap—your overlay system can now scale from 1 label to 10 at “lightning speed” on every device.
