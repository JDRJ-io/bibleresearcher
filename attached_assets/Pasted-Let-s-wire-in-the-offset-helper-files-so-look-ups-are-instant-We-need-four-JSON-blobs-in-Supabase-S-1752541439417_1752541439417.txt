Let’s wire in the offset helper files so look-ups are instant

We need four JSON blobs in Supabase Storage:

Purpose	File name (bucket path)	What it contains
Cross-ref slice offsets	references/cf1_offsets.jsonreferences/cf2_offsets.json	{ "Gen.1:1": [startByte, endByte], … }
Strong’s concordance	references/strongsVerseOffsets.jsonreferences/strongsIndexOffsets.json	Same idea—byte-ranges into big Strong’s text blobs.

(Your screenshots show the structure is correct.)

⸻

1  Upload / verify in Supabase console
	1.	Go to Storage → anointed → references.
	2.	Upload the four JSON files exactly with the names above.
	3.	In the Policies tab make sure RLS allows public download for these paths.
If the whole “anointed” bucket is already public (read-only) you’re good.

⸻

2  Add helper methods to BibleDataAPI.ts

// -------- Cross-reference offsets ----------
const cfOffsetsCache = new Map<'cf1' | 'cf2', Record<string, [number, number]>>();

export async function getCfOffsets(set: 'cf1' | 'cf2') {
  if (cfOffsetsCache.has(set)) return cfOffsetsCache.get(set)!;
  const path = `references/${set}_offsets.json`;
  const txt = await fetchFromStorage(path);     // existing helper
  const obj = JSON.parse(txt) as Record<string, [number, number]>;
  cfOffsetsCache.set(set, obj);
  return obj;
}

// -------- Strong’s offsets ----------
let strongsVerseOffsets: Record<string, [number, number]> | null = null;
let strongsIndexOffsets: Record<string, [number, number]> | null = null;

export async function getStrongsOffsets() {
  if (strongsVerseOffsets && strongsIndexOffsets) return { strongsVerseOffsets, strongsIndexOffsets };

  const [vTxt, iTxt] = await Promise.all([
    fetchFromStorage('references/strongsVerseOffsets.json'),
    fetchFromStorage('references/strongsIndexOffsets.json'),
  ]);

  strongsVerseOffsets = JSON.parse(vTxt);
  strongsIndexOffsets = JSON.parse(iTxt);
  return { strongsVerseOffsets, strongsIndexOffsets };
}



⸻

3  Use the offsets instead of range-scanning

3-A Cross-References

// inside crossReferencesWorker or its main-thread helper
const offsets = await BibleDataAPI.getCfOffsets('cf1');
const [start, end] = offsets['Gen.1:1'];
const slice = cf1Blob.slice(start, end);   // ArrayBuffer -> decode

3-B Strong’s lookup

const { strongsVerseOffsets } = await BibleDataAPI.getStrongsOffsets();
const [s, e] = strongsVerseOffsets['Gen.1:1'];
const verseStrongsData = strongsBlob.slice(s, e);



⸻

4  Guard-rail tests
	1.	Unit test (cfOffsets.spec.ts)
	•	Load offsets via API → expect key 'Gen.1:1' present and values are [number, number].
	2.	Network tab
	•	Scroll 50 verses, open a Strong’s pop-out → only the offsets file and the one Strong’s blob should download—no huge cross-ref file.
	3.	Memory profile
	•	Offsets map should be ~160 kB in heap, not entire references file.

⸻

