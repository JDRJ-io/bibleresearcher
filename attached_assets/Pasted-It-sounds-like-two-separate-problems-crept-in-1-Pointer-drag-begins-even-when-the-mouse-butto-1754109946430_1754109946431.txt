It sounds like two separate problems crept in:

1. **Pointer-drag begins even when the mouse button isn’t down** on desktop.
2. **A diagonal slip still shows up** because the browser’s own scrolling keeps running alongside your handler on some devices (especially track-pads and touch screens).

Below is a stricter, bullet-proof version that fixes both:

---

## 1  Updated “no-diagonals” hook

```ts
// useNoDiagonalStrict.ts
import { useRef } from 'react';

export function useNoDiagonalStrict() {
  const start = useRef({ x: 0, y: 0 });
  const active = useRef(false);         // TRUE only while dragging
  const scroll = useRef<(dx: number, dy: number) => void>(() => {});

  /* wheel ─────────────────────────────────────────────── */
  function onWheel(e: WheelEvent, apply: (dx: number, dy: number) => void) {
    const { deltaX: dx, deltaY: dy } = e;
    (Math.abs(dx) > Math.abs(dy) ? apply(dx, 0) : apply(0, dy));
    e.preventDefault();                           // ✓ stop browser diagonal
  }

  /* pointer (touch / mouse drag) ──────────────────────── */
  function onPointerDown(
    e: PointerEvent,
    apply: (dx: number, dy: number) => void
  ) {
    if (e.pointerType === 'mouse' && e.buttons !== 1) return;  // ignore hover
    active.current = true;
    start.current = { x: e.clientX, y: e.clientY };
    scroll.current = apply;
  }

  function onPointerMove(e: PointerEvent) {
    if (!active.current) return;                // ignore hover moves
    const dx = start.current.x - e.clientX;
    const dy = start.current.y - e.clientY;

    (Math.abs(dx) > Math.abs(dy) ? scroll.current(dx, 0) : scroll.current(0, dy));

    start.current = { x: e.clientX, y: e.clientY };
    e.preventDefault();                         // ✓ stop native pan
  }

  function onPointerUp() {
    active.current = false;
  }

  return { onWheel, onPointerDown, onPointerMove, onPointerUp };
}
```

### What changed?

| Issue you saw                                            | Fix in this version                                                      |
| -------------------------------------------------------- | ------------------------------------------------------------------------ |
| Mouse moves were handled even when no button was pressed | **Guard** `if (e.pointerType === 'mouse' && e.buttons !== 1) return;`    |
| Browser continued a diagonal pan alongside JS scroll     | `e.preventDefault()` added in **both** wheel *and* pointer-move handlers |
| Drag still active after pointer up                       | `active` flag now flipped off in `onPointerUp()`                         |

---

## 2  How to wire it

```tsx
import { useNoDiagonalStrict } from './useNoDiagonalStrict';

const { onWheel, onPointerDown, onPointerMove, onPointerUp } = useNoDiagonalStrict();

useEffect(() => {
  const el = containerRef.current!;
  const apply = (dx: number, dy: number) => {
    el.scrollLeft += dx;
    el.scrollTop  += dy;
  };

  /* Wheel */
  const wheel = (e: WheelEvent) => onWheel(e, apply);
  el.addEventListener('wheel', wheel, { passive: false });

  /* Pointer drag (touch + mouse) */
  const pd = (e: PointerEvent) => { onPointerDown(e, apply); };
  const pm = (e: PointerEvent) => onPointerMove(e);
  const pu = (e: PointerEvent) => onPointerUp();

  el.addEventListener('pointerdown', pd);
  el.addEventListener('pointermove', pm, { passive: false });
  el.addEventListener('pointerup', pu);
  el.addEventListener('pointercancel', pu);

  return () => {
    el.removeEventListener('wheel', wheel);
    el.removeEventListener('pointerdown', pd);
    el.removeEventListener('pointermove', pm);
    el.removeEventListener('pointerup', pu);
    el.removeEventListener('pointercancel', pu);
  };
}, []);
```

---

## 3  CSS—lock the browser out entirely

```css
.scrollContainer {
  /* Let JS handle everything */
  touch-action: none;             /* prevents diagonal ‘gestures’ on phones */
  overscroll-behavior: contain;   /* no scroll chaining to parent */
}
```

> **Why `touch-action: none` instead of `pan-x pan-y`?**
> We’re preventing *every* native pan with `preventDefault()` and supplying our own scroll values, so loosening it to `pan-x pan-y` just invites the browser to sneak in deltas before our script fires— exactly what caused the diagonal slip.

---

## 4  Quick test list

1. **Desktop (mouse wheel tilt):** vertical wheel → only -y moves; tilt wheel → only -x moves.
2. **Desktop (drag with mouse button down):** drag diagonally—only the dominant axis moves; release button, pointer hover no longer scrolls.
3. **Laptop track-pad:** two-finger diagonal swipe → whichever axis is larger wins per *tick*; immediately try the other axis—works.
4. **iOS/Android touch:** one-finger diagonal swipe behaves the same; lifting finger resets instantly.

If you still see diagonal motion **after** these changes, something else on the page is scrolling (often a parent element). Make sure the actual scrollable element you’re targeting is the one with `overflow:auto` and the event listeners.

Give this stricter version a try—let me know how it behaves on your end.
