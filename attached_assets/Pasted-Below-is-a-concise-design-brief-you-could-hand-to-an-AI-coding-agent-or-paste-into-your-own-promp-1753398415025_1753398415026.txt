Below is a concise “design brief” you could hand to an AI‑coding agent (or paste into your own prompt) that describes exactly what the new **single‑label overlay** must do and how it should plug into your current Next.js/Supabase Bible viewer. Feel free to adjust naming conventions, but keep the sequence and contracts intact so the agent has no ambiguity.

---

## 1  Feature Overview

> **Goal:** When the user toggles **one** label (e.g., *“what”*), show only that label’s values for every verse that is currently rendered in the viewport, using the *active translation*’s label file.
> **Label file path pattern:**
> `anointed/labels/{TRANSLATION_CODE}/ALL.json` (case‑sensitive).
> **JSON shape (example):**
>
> ```jsonc
> {
>   "Gen.1:1": { "who": ["God (Elohim)"], "what": ["the heavens","the earth"], … },
>   "Gen.1:2": { … }
> }
> ```

---

## 2  High‑level Flow

```
┌── toggleLabel("what") ───────────────────────────────────┐
│ 1. setActiveLabel("what")                               │
│ 2. ensureLabelCacheLoaded(activeTranslation)            │
│ 3. > VerseTable re‑renders                              │
│ 4.   Each VerseRow gets:                                │
│        labelVals = labelCache[translation][verseKey]?.[activeLabel] || [] │
│ 5.   VerseRow renders label bubble / column if length > 0│
└──────────────────────────────────────────────────────────┘
```

---

## 3  Interfaces & Contracts

| Name                                                           | Type                                                 | When Called                                           | Purpose                                                                                                                        |
| -------------------------------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| `setActiveLabel(labelKey:string\|null)`                        | React state setter                                   | Toggle UI                                             | Stores currently selected single label (`null` = none)                                                                         |
| `ensureLabelCacheLoaded(translationCode:string):Promise<void>` | async util                                           | Whenever `activeLabel` or `activeTranslation` changes | If `labelCache[translation]` is undefined ⇒ fetch file once from Supabase public bucket and JSON‑parse it into a plain object. |
| `labelCache`                                                   | `{ [translation:string]: LabelMap }`                 | Singleton (React context or module-level)             | Keeps each translation’s label JSON in memory for reuse.                                                                       |
| `LabelMap`                                                     | `{ [verseKey:string]: Record<LabelName, string[]> }` | Parsed JSON                                           | Exact shape of `ALL.json`.                                                                                                     |
| `VerseRow props`                                               | `{ verseKey:string, verseText:string, … }`           | Virtual / lazy list item                              | Row component now receives `activeLabel` and `labelCache` (via context or props).                                              |

---

## 4  Implementation Sketch (React/Next.js)

```tsx
// labels.ts – generic loader ------------------------------------------------
import { createClient } from '@supabase/supabase-js';
export type LabelName = 'who'|'what'|'when'|'where'|'command'|'action'|'why'|'seed'|'harvest'|'prediction';
export type LabelEntry  = Record<LabelName, string[]>;
export type LabelMap    = Record<string /*VerseKey*/, LabelEntry>;

const sb = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_KEY!);
const cache: Record<string, LabelMap> = {};

export async function ensureLabelCacheLoaded(tCode: string) {
  if (cache[tCode]) return;                       // already ready
  const { data, error } = await sb
    .storage.from('anointed')
    .download(`labels/${tCode}/ALL.json`);
  if (error) throw error;
  const json = await data.text();
  cache[tCode] = JSON.parse(json) as LabelMap;    // 1‑time parse
}

export function getLabel(tCode: string, verseKey: string, label: LabelName | null): string[] {
  if (!label) return [];
  return cache[tCode]?.[verseKey]?.[label] ?? [];
}
export function isLabelCacheReady(tCode:string){ return !!cache[tCode]; }
```

```tsx
// VerseTable.tsx – uses react‑virtual/IntersectionObserver etc. -------------
const VerseTable: React.FC = () => {
  const { activeTranslation }   = useContext(TranslationCtx);
  const { activeLabel }         = useContext(LabelCtx);          // 'what' | null
  const [ready, setReady]       = useState(isLabelCacheReady(activeTranslation));

  // Fetch labels when needed – runs only when translation or label toggles
  useEffect(() => {
    if (!activeLabel) return;                     // user turned labels off
    ensureLabelCacheLoaded(activeTranslation).then(() => setReady(true));
  }, [activeLabel, activeTranslation]);

  // Inside virtual list renderRow:
  const renderRow = ({ verseKey, verseText }: VerseRowData) => {
    const labels = ready ? getLabel(activeTranslation, verseKey, activeLabel) : [];
    return (
      <div className="row">
        <div className="verse">{verseText}</div>
        {activeLabel && (
          <div className="labelCol">
            {labels.map((v,i) => <span key={i} className="labelChip">{v}</span>)}
          </div>
        )}
      </div>
    );
  };

  return <VirtualList rowRenderer={renderRow} … />;
};
```

---

## 5  Toggle UI Logic

```tsx
// HamburgerMenu or Column Settings
const labelOpts: LabelName[] = ['who','what','when','where','command','action','why','seed','harvest','prediction'];

<labelOpts.map(name => (
  <button
     key={name}
     className={activeLabel===name ? 'on' : 'off'}
     onClick={() => setActiveLabel(activeLabel===name ? null : name)}>
     {name}
  </button>
))}
```

* Single‑select guarantee: clicking the same button again clears the label overlay; clicking a different one swaps it.\*

---

## 6  Performance & Memory Notes

| Concern                                                     | Mitigation                                                                                                      |
| ----------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **File size** – `ALL.json` per translation may be a few MB. | Load once per translation; subsequent toggles are instant.                                                      |
| **Viewport‑only verses**                                    | Because your verse table already virtualises, only rendered rows run `getLabel()`, so no extra work off‑screen. |
| **GC pressure**                                             | Cache remains for session; if you must cap RAM, add an LRU that deletes the oldest translation’s map.           |

---

## 7  What to Tell Your AI Agent (copy & paste)

> “Implement a **single‑label overlay** feature in our Next.js Bible viewer.
> *When the user toggles a label key (e.g., `"what"`), load `anointed/labels/{translation}/ALL.json` if not cached, and for each verse currently rendered show only that label’s values. Use the code skeleton in §4, respect the interfaces in §3, and keep file I/O via Supabase storage. Optimize for viewport rendering and cache one JSON per translation.*”

That summary, plus the skeleton above, gives the agent everything it needs: precise input/output paths, data shape, React hooks to tap into, and performance constraints.

---

### Next Steps for You

1. **Wire the stylesheet** for `.labelCol` and `.labelChip` (flex‑wrap, small pill design).
2. **Test** by toggling different labels while scrolling—confirm zero extra network calls after first load.
3. **Optional**: add a “Labels” column header that auto‑updates to the active label name (e.g., “WHAT”).

Once this scaffold is in place, you can expand to multi‑label overlays or color‑coding without rewriting the core loader.
