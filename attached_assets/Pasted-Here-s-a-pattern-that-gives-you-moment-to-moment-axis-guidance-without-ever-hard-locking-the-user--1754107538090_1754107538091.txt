Here’s a pattern that gives you “moment-to-moment” axis guidance without ever hard-locking the user. The same logic works for wheels, touch/pen drags, and track-pad gestures.

---

### 1. Core idea

| Gesture phase                                                  | What we do                                                                                                               |
| -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Start** (`pointerdown` \| first `wheel` tick)                | Capture the first *meaningful* delta.<br>Set `activeAxis` to `'x'` or `'y'` depending on which absolute delta is larger. |
| **Move** (`pointermove` \| subsequent `wheel`)                 | While the pointer/wheel stream is *alive*, ignore motion on the non-active axis and apply motion on `activeAxis`.        |
| **End** (`pointerup` / `pointercancel` / wheel quiet ≥ 100 ms) | Clear `activeAxis = null`. The very next gesture can pick either axis again.                                             |

Because `activeAxis` is reset every time the user lifts a finger or stops scrolling for a beat, they’re never “stuck”—each gesture is evaluated fresh.

---

### 2. Drop-in TypeScript helper (React-friendly)

```ts
// useAxisLock.ts
import { useRef } from 'react';

export function useAxisLock() {
  const axis = useRef<null | 'x' | 'y'>(null);
  const wheelTimer = useRef<number>();

  function detectAxis(dx: number, dy: number) {
    if (!axis.current) {
      axis.current = Math.abs(dx) > Math.abs(dy) ? 'x' : 'y';
    }
  }

  function clearAxis() {
    axis.current = null;
  }

  /** Wheel handler */
  function onWheel(e: WheelEvent, applyScroll: (dx: number, dy: number) => void) {
    detectAxis(e.deltaX, e.deltaY);

    if (axis.current === 'x') applyScroll(e.deltaX, 0);
    else                      applyScroll(0, e.deltaY);

    // reset after 100 ms of silence
    window.clearTimeout(wheelTimer.current);
    wheelTimer.current = window.setTimeout(clearAxis, 100);
  }

  /** Pointer drag handler trio */
  let startX = 0, startY = 0;
  function onPointerDown(e: PointerEvent) {
    startX = e.clientX; startY = e.clientY; axis.current = null;
  }
  function onPointerMove(e: PointerEvent, applyScroll: (dx: number, dy: number) => void) {
    const dx = startX - e.clientX;
    const dy = startY - e.clientY;
    detectAxis(dx, dy);

    if (axis.current === 'x') applyScroll(dx, 0);
    else                      applyScroll(0, dy);

    startX = e.clientX; startY = e.clientY;
  }
  function onPointerUp() { clearAxis(); }

  return { onWheel, onPointerDown, onPointerMove, onPointerUp };
}
```

---

### 3. Wiring it into **VirtualBibleTable.tsx**

```tsx
const { onWheel, onPointerDown, onPointerMove, onPointerUp } = useAxisLock();

useEffect(() => {
  const el = containerRef.current!;
  const apply = (dx: number, dy: number) => {
    el.scrollLeft += dx;
    el.scrollTop  += dy;
  };

  const wheel = (e: WheelEvent) => onWheel(e, apply);
  const pd    = (e: PointerEvent) => { onPointerDown(e); el.setPointerCapture(e.pointerId); };
  const pm    = (e: PointerEvent) => onPointerMove(e, apply);
  const pu    = (e: PointerEvent) => { onPointerUp(); el.releasePointerCapture(e.pointerId); };

  el.addEventListener('wheel', wheel, { passive: false });
  el.addEventListener('pointerdown', pd);
  el.addEventListener('pointermove', pm);
  el.addEventListener('pointerup', pu);
  el.addEventListener('pointercancel', pu);

  return () => {
    el.removeEventListener('wheel', wheel);
    el.removeEventListener('pointerdown', pd);
    el.removeEventListener('pointermove', pm);
    el.removeEventListener('pointerup', pu);
    el.removeEventListener('pointercancel', pu);
  };
}, []);
```

Key points:

* **No CSS `touch-action` locks** – keep `touch-action: pan-x pan-y` (or just omit it) so the browser won’t interfere.
* **`passive: false` on the wheel listener** – lets you `preventDefault()` if you want total control, but the helper above achieves the axis guide without needing it.
* **Timer-based wheel reset** emulates a “gesture end” because wheel events lack an explicit finish event.

---

### 4. Things to delete / tweak in existing code

| Existing pattern                                             | Replace with / remove                                                                        |
| ------------------------------------------------------------ | -------------------------------------------------------------------------------------------- |
| Global `axisLock` that never resets                          | Use the per-gesture lock above.                                                              |
| `touch-action: none;` on scroll container                    | Change to `pan-x pan-y` or remove.                                                           |
| Pointer capture set but **not released**                     | Always `releasePointerCapture` in `pointerup/cancel`.                                        |
| `if (axisLock === 'y') e.preventDefault()` style hard blocks | Route through the helper so only the non-dominant axis is dropped **for that gesture only**. |

---

### 5. Quick sanity checklist

1. **Desktop trackpads / wheel:** Try slow vertical, then quick horizontal flick – axis should switch on the very next flick, never within the same flick.
2. **Mouse wheel tilt (horizontal wheels):** Still works because the first delta decides.
3. **iOS/Android touch drags:** Drag 30 px mostly vertical → vertical; lift finger → next drag can be horizontal immediately.
4. **Landscape with many columns:** After one vertical scroll, a horizontal swipe should instantly scroll sideways; no more being “stuck”.

Implementing the helper above (or folding the same logic into your existing wheel-router) eliminates the permanent lock while preserving that “smart, one-axis-at-a-time” feel you liked.
