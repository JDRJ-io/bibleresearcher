Perfect. I’ll now build the complete implementation map for your AI agent to fully realize the dream version of Anointed.io — covering legacy cleanup, final feature rollouts, performance hardening, and preserving all existing strengths like the column system and menu design.

I’ll organize it in a comprehensive, phase-wise structure with clear steps for each aspect. I’ll let you know when it’s ready for your review.


# Comprehensive Implementation Plan for the Dream Bible Study Platform

## 1. **Codebase Cleanup & Legacy Removal**

Before rolling out new features, ensure the codebase is clean and free of outdated logic:

* **Eliminate Legacy Fallbacks:** Remove any remaining mock or hardcoded data sources that were used prior to Supabase. This has largely been done in Session 1 (e.g. deleting functions like `generateFallbackVerses()` and other fake data loaders). Now all Bible text and references should come **exclusively from Supabase** storage/DB. Double-check that no component tries to use old JSON files or dummy data – all should call Supabase APIs or the new data loaders.
* **Remove Obsolete UI Elements:** Strip out deprecated UI like the old loading screen or tutorial overlay. The heavy introductory loader was already removed to improve performance, so ensure it stays out. The app should launch directly into the main interface with a minimal splash or spinner as needed.
* **Consolidate State Management:** If there are multiple state sources (Zustand store vs React Context vs hooks) for similar data, unify them. For example, ensure the translation state is managed in one place. The code hints at a `translationState` in a store and a `useTranslationMaps` hook – these should be aligned so there’s a single source of truth for active translations, verses, etc. This will prevent legacy state from lingering.
* **Update TypeScript Types:** Address any remaining TypeScript warnings. For instance, the `BibleVerse` interface was updated with an optional `index` for virtual scroll – verify all verse objects use this properly and resolve any strict-mode issues (non-null assertions, etc.). This cleanup ensures the codebase is type-safe and maintainable.
* **Logging & Debug Cleanup:** Remove or gate any excessive console logs from development (or convert them to debug logs). However, keep critical warnings – e.g., the translation load smoke test logs a warning if verses are missing. Such checks are useful for dev/QA but could be silenced in production or shown via user-friendly toasts (the code already triggers a toast for translation warnings).

## 2. **Core Data Loading & Supabase Integration**

With legacy data gone, strengthen the integration with Supabase for all content:

* **Supabase as Single Data Source:** Ensure the Supabase client is correctly configured with the project URL and anon key. All Bible content (verses, cross-references, translations, prophecy data) should be retrieved from Supabase – either via **Supabase Storage buckets** (for large text files) or **Supabase Database** (for structured data like user info). Double-check environment vars and that the app is not falling back to any local files.
* **Dynamic Translation Loading:** Implement on-demand loading of Bible translations from the Supabase storage bucket. Currently, KJV is the default loaded translation, and other versions (ESV, NIV, NKJV, etc.) show placeholders. Update the translation loader so that when a user toggles a new version, the app fetches that translation’s text file from Supabase and parses it. The code already has a mechanism for this: `toggleTranslation()` uses `BibleDataAPI.loadTranslation(code)` and caches the result. Make sure this function is fully implemented to pull the `.txt` (or JSON) from the Supabase bucket (e.g. `anointed/translations/ESV.txt`) and parse it into a `Map<verseId, verseText>`. After loading, the new translation should integrate into the verse data structure so verses display side-by-side. Add console logs or metrics to confirm success – e.g., log the verse count loaded and storage path as indicated by **Task 2.1**.
* **Code Splitting Large Data:** Avoid bundling all translations into the main app build. Use dynamic `import()` for translation files so each version’s text is a separate chunk loaded only if needed. Implement **Task 5.1** by replacing any static import of translations with an async import (with `/* @vite-ignore */` to let Vite bundle them separately). Correspondingly, update Vite/Rollup config (**Task 5.2**) to use `manualChunks` so that each translation file is its own chunk file. This ensures adding a new version doesn’t bloat the initial bundle and keeps **bundle size** within limits. A bundle size check script is already in place to enforce a gzipped main bundle under 2 MB.
* **Main vs Alternate Caching:** Only **pre-cache the primary translation** for offline use, fetch alternates on demand. For example, always cache KJV by default (for guests) – this is indicated by a helper `shouldPrecacheTranslation()` that returns true only for the main translation. Implement this in the service worker config (so Workbox precaches KJV’s data file, but not all others). This way, offline users have at least one version available, and others load when online.
* **Cross-Reference Data Loading:** The cross-reference data (cf1/cf2 sets) is already loaded upfront from Supabase (over 29k references). Ensure this loading is done through a unified API (likely part of `BibleDataAPI`). The cross-ref strings are retrieved (probably from a Supabase file like `references/cf1.txt`) and stored in the app state (e.g., in `useBibleStore().crossRefs`). Verify that both sets (standard and extended) load properly and the user can switch between them (the switching functionality was implemented in Session 1).
* **Cross-Reference Text Population:** Implement the logic to display the actual verse text for cross-references. Right now, when viewing cross-references, the UI only shows placeholders or reference keys because the verse text for those references isn’t being fetched. We need to fetch the verse text for each referenced verse on the fly. **Approach:** When rendering a verse’s cross-reference list, for each reference (e.g., “John 1:1”) retrieve that verse’s text (using the currently selected main translation) and include a snippet or tooltip. We can leverage the existing verse cache: call `getVerseText(ref, main)` for each cross-ref if the translation is loaded. If the text isn’t already in memory (which it might not be if the referenced verse is outside the currently loaded slice), we have two options:

  * *On-demand fetch:* Use Supabase to fetch that specific verse text (e.g., via an RPC or a direct index lookup if we stored verses in DB) when the user expands the cross-ref.
  * *Prefetching:* Better, pre-load verses needed for cross-reference previews in advance. As part of slice loading, collect all verses that will appear as cross-reference targets in the upcoming view, and fetch them. The code outline in `useSliceDataLoader` indicates this plan (Feature Block B-1). Implement the `prefetchRemoteVerses()` function to gather cross-ref targets for the current slice of verses and ensure those verses’ texts (for the main translation at least) are loaded into the cache. This way, when a user clicks a cross-reference, the verse text is already available (meeting the <800ms display contract for previews).
* **Prophecy Data Integration:** Similar to cross-refs, prophecy fulfillment data (P, F, V columns) should be loaded and displayed. The backend logic for prophecies was reportedly fixed and tested (data fetch works), likely by loading a prophecy JSON file or table via Supabase. Now implement the UI: when the user toggles the Prophecy feature on, show three columns P, F, V. For each verse, populate those columns with markers or links if that verse has prophecy links (e.g., P might list prophecy statements that verse contains, F lists fulfillments referencing that verse). Use the `getProphecyForVerse()` from `prophecyCache` (or similar) to retrieve P/F/V for a given verse. If it returns references, display them (maybe as small icons or text in the cell). If these references need verse text previews, treat them like cross-refs (fetch their text as needed). In summary, connect the existing prophecy data retrieval to the new column UI so that toggling it on actually populates content (instead of empty columns).
* **Global Search Functionality:** Implement a robust search feature to allow users to find verses or words across the Bible (and potentially across all loaded translations). This is a significant feature (Next Priority #3). The plan: Add a search bar (perhaps in the header or accessible via the menu). When a query is entered, search through verse text. Since 31,102 verses per translation is a large dataset, consider:

  * If online, leverage Supabase SQL full-text search if the verses are stored in a DB table (this might require importing verses into a Supabase table or using Supabase’s full-text capabilities).
  * If offline or to avoid huge downloads, implement a client-side search on the cached data. For example, search within the Map of the main translation (and any alternates loaded). We might restrict offline search to only translations already loaded or to the main translation for simplicity.
  * Another approach is to maintain a lightweight index (like a trie or inverted index) for verse text. An AI agent could generate this index for the main translation and bundle it or store in IndexedDB for offline use. But initially, a simpler brute-force search through the in-memory Map might suffice for the main translation (31k entries is feasible to scan quickly in JS).
  * Provide results as a list of verses (reference and snippet). Support basic filters (maybe restrict to certain books or translations if multiple loaded). This feature will likely involve writing a new component and possibly a new API route for search if doing server-side queries.
* **Strong’s Concordance Integration:** Connect the original language concordance data so users can delve into Greek/Hebrew word meanings (Priority #4). The UI for this exists in the verse **ExpandedVerseOverlay**: when a verse is expanded, it lists **Strong’s words** with an icon and creates a list of clickable word chips. We need to:

  * **Load Strong’s Data:** likely have a dataset of Strong’s numbers to definitions (could be a JSON or a database table). An AI agent can be tasked to load this data into a suitable format (maybe a dictionary in a Web Worker or an IndexedDB table). Because this dataset can be large, do **not** preload it entirely. Instead, load on-demand. For example, if a verse has Strong’s tags (the `verse.strongsWords` array), each item might contain a Strong’s ID or an original word reference. When rendering these, spawn a **Strong’s Worker** (similar to the translation worker) or reuse the translation worker to fetch the definitions for those IDs from Supabase or a local file. The code already initializes a `translationWorker.js` and posts an INIT with an API key – possibly that worker can handle Strong’s as well. If not, create a separate `strongsWorker`.
  * **Display Definitions:** Implement the `onStrongsClick(word)` handler in `ExpandedVerseOverlay`. When the user clicks an original-language word chip, show the Strong’s definition and details. This could be a small popover or side panel. For example, clicking could open a tooltip near the word or populate a section in the overlay with the word’s meaning, pronunciation, and cross-refs. The simplest implementation: on click, call the worker or API to get the definition text, then use a React state to show it (maybe as a `<div>` or modal).
  * **UX Considerations:** Add a loading state if the definition fetch takes time. Also, avoid blocking the main thread – performing the lookup in a web worker is ideal. The PWA caching strategy will treat Strong’s data as network-only (not cached) due to size, so ensure the app can fetch it live (perhaps requiring internet). If offline, maybe disable Strong’s features or cache a subset of frequently used entries.

## 3. **User Interface & Layout Enhancements**

The core layout (an Excel-style multi-column table) is in place, but we must finish connecting interactive features and polish the UI according to the design spec:

* **Multi-Column Layout Implementation:** The table layout is defined in the **UI layout spec**. We have up to 20 column “slots” (Reference, Notes, Main translation, Cross-References, Dates, 12 alternates, Prophecy P/F/V). Confirm that the table rendering code iterates through visible columns and renders cells correctly. Based on the design snippet, the virtualized row renderer should map visible columns to cells. Ensure that:

  * The **Reference column** (slot 0) is always visible and sticky (fixed to the left) so that as you scroll horizontally, verse numbers stay in view.
  * The **Main Translation column** (slot 2 by default) is visible by default and other columns (notes, alternates, cross-refs, etc.) default to hidden off-screen until toggled.
  * The **Column headers** are properly rendered with a sticky header bar. The code already calculates whether to center the columns or left-align based on total width vs viewport. This ensures if only a few columns are visible, they appear centered (per spec, centered if ≤3 columns). Verify this centering logic works and that for many columns it left-aligns with horizontal scroll.
  * **Resizing & Dragging:** The UI should allow users to reorder columns (drag & drop) and resize column width when “unlocked”. These features were planned in the spec: drag and resize toggles exist in the menu, enabling a drag-and-drop library and showing resize handles. We need to implement:

    * A mechanism (possibly using a library like `react-beautiful-dnd`) to handle drag-and-drop of column headers when unlock is enabled. On drop, call a state update (e.g., `columnState.reorder(from, to)`) to swap the columns. Persist the new order to localStorage (or user prefs if logged in) so the order remains next session (Behavior Contract C-1).
    * For resizing, perhaps show a draggable gutter on column edges when “Unlock resize” is toggled. Enforce a minimum width (60px per contract C-4). The `columnState.resize(slot, deltaRem)` function should adjust the width in state, and the UI should reflect it (likely the `.w-col` CSS class is used with a width in `rem` units). Make sure to persist user-set widths if needed, or at least keep them for the session.
  * **Column Visibility Toggles:** The user should be able to show/hide each column type via the menu. Some toggles are already present (Cross-Refs, Prophecies, maybe others). Implement these by calling the Zustand store’s `setVisible(slot, boolean)` for the corresponding slot. For example, toggling “Cross References” sets slot 3 visible, toggling “Prophecy” sets slots 17–19 visible as a group. When toggling on, also trigger loading of data if not already loaded (e.g., load crossRef data or prophecy data). When toggling off, simply hide the columns. Persist these preferences – for guests, you might just use localStorage; for logged-in users, save to a `userPreferences` table on Supabase (the design indicates storing column visibility server-side).
  * **Notes Column:** Slot 1 is designated for user notes. Implement the UI for this column: if visible, each verse’s cell in the Notes column should show either the user’s note (if one exists for that verse) or an affordance to add a note (e.g., a “+” icon or faint text “Add note”). Clicking it could open a small editor or modal to enter the note. This ties into user data (discussed in section 5 below). Initially, for guests or if not logged in, this column might remain hidden or read-only. Once the user system is in place, ensure toggling “Notes” on triggers a check: if the user is not logged in, perhaps prompt login (since persisting notes requires an account). If logged in, load their notes from the database (and/or Dexie if offline) for the verses in view and display them.
  * **Dates Column:** Slot 4 (Dates) appears to be intended to show dates associated with a verse (perhaps historical dates or timeline info). This is likely a lower priority feature. If it’s part of the dream spec, outline how to implement it: presumably, each verse might have an array of dates (`verse.dates[]`). If the data is available (maybe in the verse metadata), display them. If not populated yet, this column can be left for later or filled with placeholder. It’s default hidden, so it won’t affect initial launch if incomplete.

* **Menu & Settings Panel:** The “hamburger” main menu has been designed and partially implemented. Now fully wire up its controls:

  * The menu should open a panel with various settings (theme, font size, toggles for columns, and auth links). Ensure the menu button in the header toggles the panel visibility (likely already functional).
  * **Theme Switcher:** The app supports multiple themes (light/dark/sepia/aurora/electric/fireworks). Confirm the menu has a theme selector (could be a toggle or a list of themes). Wire this to the theme context (perhaps using `next-themes` library given it’s in dependencies). Changing the theme should update CSS variables or classes accordingly. This was working already, but ensure the menu UI reflects the current theme and can change it.
  * **Font Size (Text Size Presets):** Implement the size presets (S/M/L/XL) which adjust the base font-size multiplier. The spec suggests using CSS variables `--baseRem` and `--sizeMult`. Possibly, the menu offers discrete options or a slider. When the user selects a size, set `--sizeMult` to the corresponding value (e.g., S=0.85, M=1.0, L=1.35, XL=1.7 as per Contract C-3) on the `<html>` or `:root`. Persist this choice (could be localStorage, as indicated for size presets). The UI spec note says “Size menu sets the variable and persists it” – implement that. This allows users to easily scale text/UI for readability.
  * **Column Toggles & Tools:** As covered, include menu switches for each column type (Cross-Refs, Prophecy, Notes, etc.) which call the visibility logic. Also include toggles for “Unlock drag” and “Unlock resize” modes. These toggles do not persist beyond the session (they’re more like tool modes), so no need to save them – just ensure they trigger the corresponding state (e.g., set a flag in state that the UI uses to enable drag handles or resize handles). When these are off, the UI should hide drag handles and lock column order/width.
  * **Text Alignment:** Provide a control to set verse text alignment (Left/Center/Right). This can apply a Tailwind utility class to the verse text container. For example, center alignment might be nice for parallel columns. The user choice can be saved (likely in preferences). Implement a simple toggle or cycle through the three options in the menu.
  * **Canon/Chronological Order:** If the app supports switching the verse ordering (standard canonical order vs chronological order of verses/events), provide a toggle. The spec references a control for “Canon / Chrono order” that affects the verse key array and is persisted via URL hash and store. This likely means switching to a predefined chronological reading plan ordering. Implement by preparing an alternate index of verses in chronological order (perhaps precomputed). When toggled, reload the verse list in that order. Persist by updating the URL (so a refresh retains it) and maybe storing the choice in state. This is an advanced feature, but including it completes the “dream” spec. If not already done, it can be added later, but leaving a placeholder in the menu now (grayed out or with a note) might be acceptable until fully implemented.

* **Responsive Design & Mobile:** Verify the layout adapts to smaller screens. The CSS media queries define base font sizes and column widths for mobile vs desktop. On phones (max-width 639px), it sets a smaller base REM and smaller base column width (420px). Ensure that on a phone-sized screen:

  * The table can scroll horizontally (since even one column might be 420px).
  * The sticky header’s `top` offset is correct for mobile (the code sets `top: 38px` presumably for a smaller header height on mobile). Check that the header bar doesn’t overlap content and remains visible.
  * Possibly hide or compress certain UI elements on mobile (for example, maybe the menu is full-screen modal on mobile).
  * Test toggling columns on a small screen; the anchor/centering logic should automatically left-align if too many columns are on a small viewport. The app should remain usable (likely only 1-2 columns visible comfortably on a phone, which is fine).

* **Polish UI Elements:** Go through the UI and finalize any rough edges:

  * The **Online/Offline indicator** is already functional – ensure it’s visible (perhaps in header or footer) and clearly shows offline status (e.g., grey or red icon with tooltip “Offline”).
  * Implement any **loading spinners or placeholders** for data loads. For instance, when a new translation is toggled and loading, show a spinner icon in that column header or a toast “Loading NIV…”. Similarly, when performing search or fetching Strong’s info, give user feedback. Use the toast system (already implemented) for non-blocking notifications.
  * **Footer and Info:** If there’s a footer with app info or links (as mentioned in passing), ensure it’s up-to-date and styled. Possibly include version number, copyright, or a link to a help page.

## 4. **Offline Capability & Progressive Web App (PWA)**

The application should work offline and behave like a reliable PWA. We will finalize the service worker and caching strategy as documented:

* **Service Worker Registration:** Use `workbox-window` to register the service worker in the app (likely done in App.tsx). Make sure the registration is called on app load and that the SW covers the app scope (“/”).
* **Precaching Shell & Assets:** Configure the Workbox PWA plugin (already in use) to precache essential assets – HTML, CSS, JS bundles, and the **main translation data**. The PWA guide shows that at build time the plugin generates a precache manifest and runtime routes. Ensure in `vite.config.ts` or equivalent that the plugin is set up to precache the necessary files. The HTML shell should use **NetworkFirst** caching (to get updates within 24h), while static assets can be CacheFirst.
* **Runtime Caching Data:** Implement runtime caching rules as per the design:

  * Bible translations (`translations/*.txt` or `.json`) – use **CacheFirst** with a reasonable max entries (say 12 versions) and max age (30 days). This allows already loaded versions to be available offline. We will rely on the dynamic loading mechanism to fetch them once; the SW should then cache them so subsequent loads (and reading offline) work.
  * Cross-reference and prophecy files (small JSON/TSV files) – use **StaleWhileRevalidate**. They aren’t huge, but we want to keep them updated occasionally. The SW can fetch updated ones in background while serving the cached ones.
  * Strong’s data – because it’s large, do **NetworkOnly** (no caching in SW). The user will need to be online for Strong’s lookups, which is acceptable.
  * Any API calls to Supabase for auth or RPC – those should remain **NetworkOnly** as well (we don’t want to cache responses that modify data).
* **Offline Data Storage:** Leverage **Dexie (IndexedDB)** for app data that needs to persist offline beyond just caching. The Dexie schema is set up for user-created data: queued\_mutations, bookmarks, highlights, notes. Ensure this database is initialized on app startup. When the user is offline and creates a note, bookmark, or highlight, immediately store it in Dexie and mark it as pending (this addresses Behavior Contract O-1: any offline mutation enqueues within 100ms).
* **Background Sync for Mutations:** Integrate a background sync or online event handler to process queued mutations. The service worker (with Workbox) can utilize a Background Sync plugin: as shown, an `anointed_sync_queue` is configured. Ensure that whenever the app goes online or the SW gets a 'sync' event, it triggers a script (possibly `queueSync.ts`) to read all queued\_mutations from Dexie and send them to Supabase (via RPC or direct DB calls). Implement logic to handle each type of mutation:

  * Notes: send the new/updated note to Supabase (either via REST if using Supabase functions or via the Express API to the database).
  * Bookmarks & Highlights: similarly sync to the server. After successful sync, remove them from the queue (and maybe mark them as synced in local storage if keeping a local copy).
  * If sync fails (network down again or server error), keep items in the queue for next time. Ensure the queue doesn’t grow indefinitely (maybe purge very old ones after a certain period, though the spec says retention 48h).
* **PWA Installability:** The provided `manifest.json` is configured with name, icons, theme color, etc. Confirm these are linked in the HTML. The app should prompt the user or allow them to “Add to Home Screen” on mobile. Test that the PWA can install and launch offline showing at least the cached KJV text.
* **SW Update Flow:** Implement a user-friendly update mechanism. The docs suggest using `workbox-window` to listen for the waiting service worker and prompt the user. We should show a toast or banner “New version available – refresh to update.” The code can call `skipWaiting()` on user confirmation to activate the new SW. Ensure that this flow is tested so users get updates without confusion.
* **Offline UX:** Make it clear when the app is offline. Continue showing the connectivity indicator. If the user tries to load a translation or resource that isn’t available offline, handle it gracefully – perhaps show an alert “This feature is unavailable offline” rather than a blank screen. Ideally, cache as much as possible of the core content so the app is highly usable offline (all verses of main translation and any others the user has loaded before).

## 5. **User Accounts, Preferences, and Data Persistence**

To unlock the full feature set (notes, multi-version access, etc.), implement a robust user authentication and data persistence layer:

* **User Authentication (Login/Signup):** Set up a system for users to create accounts and log in. Given the stack, we can use **Passport.js (local strategy)** with an Express server. Implementation steps:

  * Create a database table (via Drizzle ORM or Supabase) for users with fields like id, email, hashed\_password, created\_at, etc. Use a strong hashing algorithm (bcrypt) for passwords.
  * Build Express routes for **/auth/register** and **/auth/login**. On registration, hash the password and insert the new user into the DB (ensure unique email/username). On login, verify credentials and establish a session. Use `express-session` with a secure cookie; store sessions in Postgres via connect-pg-simple for persistence. (We have `passport-local` in dependencies and session store, so this is aligned.)
  * Integrate the login flow in the UI: in the menu, the “Sign In / Sign Up” links should open forms (either on the main interface via a modal or on a separate page/route). The forms will POST to the Express endpoints (we might use fetch from the client to an `/api/login` route that proxies to the Express server logic). On success, the session cookie is set. Possibly use a client-side state (or simply rely on cookie and a check endpoint) to reflect logged-in status.
  * Provide feedback on auth errors (invalid login, etc.) via toasts or inline messages. Also consider email verification or password reset flows in the future, but not mandatory for initial implementation.
* **Account-Based Feature Gating:** When a user is logged in, unlock additional capabilities:

  * **Access to All Translations:** As noted, in guest mode only a limited set of versions are enabled (others greyed out). Implement this by maintaining a list of free vs premium translations. In the menu’s translations list, if not logged in, disable the checkboxes for the ones reserved for registered users. On login, those become enabled. The actual data loading is the same, but this encourages sign-up for full access.
  * **Persisted User Preferences:** Create a table or JSON column in the database for user preferences (like which columns they had visible, preferred theme, last reading position, etc.). When a logged-in user toggles columns or changes settings, save it to Supabase (e.g., via a `updatePreferences` API call). Next time they log in on another device, they get the same layout. For implementation, you might save the whole `ColumnState.columns` array and other settings in one JSON blob keyed by user\_id. Use Drizzle ORM to define this model and query/update it easily. If the user is offline, you can queue the preferences update in Dexie to sync later.
* **Notes, Bookmarks, and Highlights:** These personal study tools need full implementation:

  * **Notes:** Allow users to write notes tied to verses. Backend: create a `notes` table (with fields: id, user\_id, verse\_ref, content, updated\_at). In the UI, as mentioned, the Notes column will surface these. For adding a note: the user might click a verse’s note cell (or maybe a “Add Note” button on that verse’s row) to open a small editor. Save the note via an API call to the server (or directly to Supabase if using Supabase client). Optimistically update the UI to show the note text in the cell. If offline, store the note in Dexie (as per queued\_mutations) and mark it so it syncs later (contract O-1). On coming online, sync it to the server and then fetch the note ID (to reconcile if needed). Also, on initial load for a logged-in user, load all their notes for the currently displayed book or chapter to populate the Notes column. Possibly use an index or fetch notes by a range of verses to avoid pulling all at once.
  * **Bookmarks:** Let users bookmark verses. This could be a star icon on each verse row or a context menu option. Toggling it adds/removes an entry in a `bookmarks` table (fields: id, user\_id, verse\_ref, maybe a label or category). In the UI, consider an indicator on the verse (like a small star that lights up if bookmarked). Also, a user might want to see a list of all bookmarks (perhaps a section in the menu or a separate page). Implementing that list can be a later enhancement; initially, focus on the ability to mark/unmark and persist. Similarly handle offline bookmarking by queuing the mutation and visual feedback.
  * **Highlights:** Allow users to highlight a portion of verse text. This is more involved because it requires selecting text ranges. However, some groundwork might be in place: there’s a `useTextSelection` hook and the Dexie schema for highlights includes a `range` field. Implementation: when a user selects text in a verse, show a small popup (perhaps a floating toolbar) with color options. On choose, wrap the selected text in a `<mark>` or styled span in the UI, and save the highlight (store the verse\_ref, range (maybe the exact selected substring or indices), color, etc.). The app should render highlights by checking stored highlights and applying styles to the verse text on render. This might require modifying how verse text is output (splitting by ranges). It’s complex but doable with an AI agent writing careful text-splitting logic.

    * If implementing partial verse highlights is too much initially, a simpler interim step: allow highlighting an entire verse (toggle highlight on the verse level). This could be indicated by a background color on that verse’s row. Save just verse\_ref and a default color. This gives a basic highlight feature until fine-grained highlights are ready.
  * **Sync & Persistence:** For all these (notes, bookmarks, highlights), ensure two-way sync. On login, fetch the user’s data from server and populate the UI (notes in the margin, stars on verses, etc.). When a user performs an action online, update the server immediately. If offline, queue it. Also, if the app starts offline, load whatever last synced data we have from IndexedDB so the user sees their existing notes/bookmarks and can add to them. Once online, reconcile any new changes.
* **Profile and Settings:** In the menu, when logged in, replace the “Sign In” with user info. Possibly show the username/email and a “Logout” button. Also include entries like “My Notes” or “My Bookmarks” which could lead to summary views. Implement logout by clearing the session (calling an API endpoint to destroy session cookie).
* **Security & Testing:** Ensure proper security: sanitize inputs for notes (to prevent script injection – probably just treat everything as plain text or markdown). Enforce authentication on data routes (notes, etc.) – the Express server should check `req.isAuthenticated()` or similar for those endpoints. Use HTTPS in production for secure cookies. As AI is implementing, double-check these via testing.

## 6. **Performance Optimizations and Verification**

After implementing all features, the AI agent should focus on performance tuning and thorough testing to meet all acceptance criteria:

* **Virtual Scrolling Performance:** The virtualized table must remain smooth even with all verses. The current implementation keeps a buffer of \~60 verses in the DOM at once, which drastically reduces memory (down to \~200MB from 3GB). Verify that this holds with multiple columns – having many columns shouldn’t increase the row count, so it should be fine. Test on mobile devices to ensure no jank. If any performance issues arise (e.g., initial load parsing many translations), consider moving more work off the main thread. The plan to parse translations in a Web Worker is key (the `translationWorker` usage should handle heavy JSON parsing). Ensure that worker is properly utilized for each translation load (perhaps the `BibleDataAPI.loadTranslation` posts a message to the worker and waits for a response).
* **Bundle Size & Loading Time:** With code-splitting of translations and lazy-loading of heavy features, the initial load should be relatively light. Run the `bundle-check.js` script to confirm the main bundle is under 2 MB gzipped. If not, identify large dependencies and use techniques like dynamic import or removing unused libraries. The presence of many Radix UI components in package.json is noted – tree-shaking should remove any not used, but double-check that we only import what we need for the UI.
* **Memory Management:** Ensure no memory leaks – e.g., when unmounting components like the verse overlay, terminate any event listeners or workers (the `useTranslationWorker` already terminates the worker on cleanup). Also, when switching books or large content, ensure old data is freed if not needed (though caching is good, avoid duplicating large structures). The `masterCache` usage should ideally be an LRU – if memory is a concern, we could evict some translations if too many loaded, but given at most \~12 loaded plus crossrefs, it should be fine.
* **Behavior Contracts Testing:** Utilize the provided **Behavior Contracts** document as a checklist for testing:

  * Anchor & scrolling (A-1, A-2, A-3): verify the anchor logic (the verse at 50% viewport is tracked, programmatic jumps work, no more than 250 DOM rows are present). These were likely implemented with tests; run those tests or manually check by scrolling.
  * Cross-Reference interactions (X-1, X-2, X-3): test that clicking a cross-ref link navigates to that verse quickly (we should call something like `setAnchorByRef(ref)` to jump and maybe flash the row). Ensure the highlight flash (0.5s blue highlight) occurs to draw attention – implement that if not present (could add a temporary CSS class on navigation). And importantly, confirm the verse preview tooltip appears in under 800ms – with our prefetch implemented, this should be met.
  * Column visibility & sizing (C-1…C-4): verify column order persistence (simulate reordering columns, refresh page – order should restore from localStorage or user prefs). Check centering rule for ≤3 columns (the code handles this with `shouldCenter` logic). Test the size preset multipliers as mentioned. And ensure the resize doesn’t let columns vanish below 60px – set a min-width in CSS or in the resize handler logic.
  * Offline data (O-1, O-2): turn off network and create a note, then restore connection – within a few seconds the note should sync up and appear on another device or after a reload. Test multiple queued actions in airplane mode and then going online. The system should handle them gracefully (perhaps showing a “syncing…” indicator).
* **Additional Testing:** Conduct cross-browser tests (Chrome, Firefox, Safari) for compatibility. Mobile web testing (Android/iOS) since PWA is aimed for those. Run through typical user flows: open app offline, search for a verse, toggle themes, login, add a highlight, etc., to catch any edge-case bugs. Write or update any Cypress end-to-end tests to automate these if possible.

By following this implementation map, the AI agent will integrate all the planned features into the “dream” Bible study website. We will end up with a feature-complete, polished application: one that **efficiently loads scripture from Supabase**, presents it in a **flexible multi-column layout**, allows **deep study with cross-references and original-language tools**, supports **user personalization (notes, highlights, saved settings)**, and works **offline as a PWA** for an uninterrupted study experience. All legacy cruft will be gone, replaced by a clean, modern codebase ready for maintenance and future enhancements.

**Sources:** The above plan synthesizes the project’s design documents and development notes, including the UI layout spec, the initial implementation session report, known feature gaps from recent status updates, and technical guides for PWA/offline integration. All features and fixes are derived from the provided documentation to ensure alignment with the envisioned platform.
